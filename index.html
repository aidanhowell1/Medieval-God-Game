<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <title>Medieval God Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel:wght@400;700&display=swap');
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Cinzel', serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    }
    
    /* Custom scrollbar with medieval theme */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    ::-webkit-scrollbar-track {
      background: rgba(20, 15, 10, 0.7);
      border-radius: 5px;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(to bottom, #b58a3a, #8b6914);
      border-radius: 5px;
      border: 1px solid #5a4310;
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(to bottom, #d4a76a, #b58a3a);
    }
    
    /* Enhanced button animations with multiple effects */
    @keyframes pulse-gold {
      0% { 
        box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4);
        transform: scale(1);
      }
      50% { 
        box-shadow: 0 0 0 12px rgba(245, 158, 11, 0);
        transform: scale(1.03);
      }
      100% { 
        box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
        transform: scale(1);
      }
    }

    @keyframes shimmer {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }

    @keyframes glow-pulse {
      0%, 100% { 
        filter: brightness(1) drop-shadow(0 0 5px rgba(245, 158, 11, 0.3));
      }
      50% { 
        filter: brightness(1.15) drop-shadow(0 0 15px rgba(245, 158, 11, 0.6));
      }
    }

    @keyframes border-rotate {
      0% { 
        border-image: linear-gradient(0deg, #fcd34d, #f59e0b, #d97706) 1;
      }
      100% { 
        border-image: linear-gradient(360deg, #fcd34d, #f59e0b, #d97706) 1;
      }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-3px); }
    }

    @keyframes ripple {
      0% {
        transform: scale(0, 0);
        opacity: 0.7;
      }
      100% {
        transform: scale(40, 40);
        opacity: 0;
      }
    }

    .pulse-animation {
      animation: 
        pulse-gold 2s infinite,
        shimmer 3s infinite,
        glow-pulse 4s infinite ease-in-out,
        float 6s infinite ease-in-out;
      position: relative;
      overflow: hidden;
      border-image: linear-gradient(45deg, #fcd34d, #f59e0b, #d97706) 1;
      border-image-slice: 1;
    }

    .pulse-animation::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(245, 158, 11, 0.7), transparent);
      animation: shimmer 3s linear infinite;
    }

    .pulse-animation::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, transparent, rgba(245, 158, 11, 0.3), transparent);
      border-radius: inherit;
      opacity: 0;
      z-index: -1;
      transition: opacity 0.3s ease;
    }

    .pulse-animation:hover::after {
      opacity: 1;
      animation: border-rotate 3s linear infinite;
    }

    /* Enhanced button styling with medieval theme */
    .medieval-btn {
      background: linear-gradient(135deg, rgba(139, 69, 19, 0.9) 0%, rgba(101, 67, 33, 0.9) 100%);
      border: 2px solid #8b6914;
      border-radius: 8px;
      box-shadow: 
        0 6px 12px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3);
      color: #fcd34d;
      font-family: 'MedievalSharp', cursive;
      font-weight: bold;
      text-shadow: 0 2px 3px rgba(0, 0, 0, 0.8);
      padding: 10px 18px;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .medieval-btn:hover {
      background: linear-gradient(135deg, rgba(160, 82, 45, 0.95) 0%, rgba(139, 69, 19, 0.95) 100%);
      transform: translateY(-3px) scale(1.05);
      box-shadow: 
        0 12px 24px rgba(0, 0, 0, 0.6),
        0 0 25px rgba(245, 158, 11, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: #fcd34d;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9);
    }

    .medieval-btn:active {
      transform: translateY(-1px) scale(1.02);
      box-shadow: 
        0 5px 10px rgba(0, 0, 0, 0.4),
        inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .medieval-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(245, 158, 11, 0.7), transparent);
    }

    /* Ripple effect */
    .medieval-btn {
      position: relative;
      overflow: hidden;
    }

    .medieval-btn::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .medieval-btn:active::after {
      width: 300px;
      height: 300px;
    }

    /* Enhanced building button styles */
    .building-btn {
      background: linear-gradient(135deg, rgba(60, 45, 30, 0.9) 0%, rgba(40, 30, 20, 0.9) 100%);
      border: 2px solid #8b6914;
      border-radius: 10px;
      box-shadow: 
        0 6px 12px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .building-btn:hover {
      background: linear-gradient(135deg, rgba(80, 60, 40, 0.95) 0%, rgba(60, 45, 30, 0.95) 100%);
      transform: translateY(-3px) scale(1.08);
      box-shadow: 
        0 12px 24px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(245, 158, 11, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border-color: #fcd34d;
    }

    .building-btn:active {
      transform: translateY(-1px) scale(1.04);
      box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.3),
        inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .building-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(245, 158, 11, 0.6), transparent);
    }

    /* Add subtle glow to all buttons on hover */
    .medieval-btn:hover,
    .building-btn:hover {
      animation: glow-pulse 2s infinite;
    }

    /* Resource bar with medieval styling */
    .resource-bar {
      background: linear-gradient(135deg, rgba(40, 30, 20, 0.95) 0%, rgba(20, 15, 10, 0.95) 100%);
      border: 2px solid #8b6914;
      border-radius: 10px;
      box-shadow: 
        0 6px 12px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .resource-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(245, 158, 11, 0.5), transparent);
    }

    .resource-icon {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
      vertical-align: middle;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 50%;
      border: 1px solid rgba(181, 138, 58, 0.5);
      box-shadow: 
        0 3px 6px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .resource-icon svg {
      width: 20px;
      height: 20px;
    }

    .resource-value {
      font-family: 'MedievalSharp', cursive;
      font-size: 20px;
      font-weight: bold;
      text-shadow: 0 2px 3px rgba(0, 0, 0, 0.8);
      color: #fcd34d;
    }

    /* Quest notification with enhanced styling */
    .quest-notification {
      animation: slide-down 0.7s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      background: linear-gradient(135deg, rgba(40, 30, 20, 0.95) 0%, rgba(20, 15, 10, 0.95) 100%);
      border: 2px solid #8b6914;
      border-radius: 10px;
      box-shadow: 
        0 10px 20px rgba(0, 0, 0, 0.6),
        0 0 25px rgba(245, 158, 11, 0.3);
      position: relative;
      overflow: hidden;
      animation: quest-glow 3s infinite alternate;
    }

    .quest-notification::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(to right, #b58a3a, #fcd34d, #b58a3a);
      background-size: 200% 100%;
      animation: shimmer 3s linear infinite;
    }

    .quest-notification h3 {
      font-family: 'MedievalSharp', cursive;
      color: #fcd34d;
      text-shadow: 0 2px 3px rgba(0, 0, 0, 0.8);
      margin-bottom: 8px;
    }

    .quest-notification p {
      color: #f3f4f6;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }

    /* UI Panel styling with medieval theme */
    .ui-panel {
      background: linear-gradient(135deg, rgba(40, 30, 20, 0.95) 0%, rgba(20, 15, 10, 0.95) 100%);
      border: 2px solid #8b6914;
      border-radius: 12px;
      box-shadow: 
        0 10px 20px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .ui-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(to right, #b58a3a, #fcd34d, #b58a3a);
      background-size: 200% 100%;
      animation: shimmer 3s linear infinite;
    }

    .ui-panel::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(245, 158, 11, 0.5), transparent);
    }

    .ui-panel h2 {
      font-family: 'MedievalSharp', cursive;
      color: #fcd34d;
      text-shadow: 0 2px 3px rgba(0, 0, 0, 0.8);
      text-align: center;
      margin-bottom: 15px;
      position: relative;
    }

    .ui-panel h2::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 25%;
      right: 25%;
      height: 1px;
      background: linear-gradient(to right, transparent, #8b6914, transparent);
    }

    /* Building menu styling */
    .building-menu {
      background: linear-gradient(135deg, rgba(40, 30, 20, 0.95) 0%, rgba(20, 15, 10, 0.95) 100%);
      border: 2px solid #8b6914;
      border-radius: 12px;
      box-shadow: 
        0 10px 20px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .building-menu::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(to right, #b58a3a, #fcd34d, #b58a3a);
      background-size: 200% 100%;
      animation: shimmer 3s linear infinite;
    }

    /* Health bar styling */
    .health-bar {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 4px;
      height: 5px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
    }

    .health-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.4s ease;
      position: relative;
      overflow: hidden;
    }

    .health-bar-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.5), transparent);
    }

    .health-bar-fill.high {
      background: linear-gradient(to right, #10b981, #34d399);
    }

    .health-bar-fill.medium {
      background: linear-gradient(to right, #f59e0b, #fcd34d);
    }

    .health-bar-fill.low {
      background: linear-gradient(to right, #ef4444, #f87171);
    }

    /* Corner decorations for UI panels */
    .corner-decoration {
      position: absolute;
      width: 16px;
      height: 16px;
      border-color: #8b6914;
      border-style: solid;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }

    .corner-decoration.top-left {
      top: -3px;
      left: -3px;
      border-width: 3px 0 0 3px;
    }

    .corner-decoration.top-right {
      top: -3px;
      right: -3px;
      border-width: 3px 3px 0 0;
    }

    .corner-decoration.bottom-left {
      bottom: -3px;
      left: -3px;
      border-width: 0 0 3px 3px;
    }

    .corner-decoration.bottom-right {
      bottom: -3px;
      right: -3px;
      border-width: 0 3px 3px 0;
    }

    /* Territory indicator styling */
    .territory-indicator {
      position: absolute;
      border-radius: 50%;
      border: 3px dashed rgba(245, 158, 11, 0.6);
      pointer-events: none;
      z-index: 5;
      box-shadow: 0 0 10px rgba(245, 158, 11, 0.3);
    }
    
    /* Prevent zooming on mobile devices */
    html {
      touch-action: manipulation;
    }

    /* Prevent double-tap to zoom */
    * {
      touch-action: manipulation;
    }
    
    /* Sound control button */
    .sound-control {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(40, 30, 20, 0.9) 0%, rgba(20, 15, 10, 0.9) 100%);
      border: 2px solid #8b6914;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
    }
    
    .sound-control:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
    }
    
    .sound-control svg {
      width: 24px;
      height: 24px;
      fill: #fcd34d;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-gray-800">
  <!-- Day/Night Overlay -->
  <div id="dayNightOverlay"></div>
  
  <!-- Resource Bar -->
  <div id="resourceBar" class="absolute top-5 left-5 bg-stone-900 bg-opacity-90 text-amber-50 p-4 rounded-lg shadow-lg border-2 border-amber-800 z-20">
    <div class="flex space-x-6">
      <div class="flex items-center">
        <div class="resource-icon bg-amber-800 rounded-full flex items-center justify-center">
          <span class="text-lg">🪵</span>
        </div>
        <span id="woodCount" class="ml-2 font-bold">100</span>
      </div>
      <div class="flex items-center">
        <div class="resource-icon bg-gray-600 rounded-full flex items-center justify-center">
          <span class="text-lg">🪨</span>
        </div>
        <span id="stoneCount" class="ml-2 font-bold">100</span>
      </div>
      <div class="flex items-center">
        <div class="resource-icon bg-green-700 rounded-full flex items-center justify-center">
          <span class="text-lg">🍖</span>
        </div>
        <span id="foodCount" class="ml-2 font-bold">100</span>
      </div>
      <div class="flex items-center">
        <div class="resource-icon bg-blue-700 rounded-full flex items-center justify-center">
          <span class="text-lg">👥</span>
        </div>
        <span id="populationCount" class="ml-2 font-bold">2/5</span>
      </div>
    </div>
  </div>
  
  <!-- Quest Notification -->
  <div id="questNotification" class="absolute top-5 left-1/2 transform -translate-x-1/2 bg-stone-900 bg-opacity-90 text-amber-50 p-4 rounded-lg shadow-lg border-2 border-amber-800 z-20 hidden quest-notification">
    <div class="flex items-center">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-amber-400 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <div>
        <h3 class="font-bold text-amber-200">New Quest!</h3>
        <p id="questText" class="text-sm">Build a Town Hall to establish your settlement</p>
      </div>
    </div>
  </div>
  
  <!-- UI Panel -->
  <div id="ui" class="absolute top-5 right-5 bg-stone-900 bg-opacity-90 text-amber-50 p-5 rounded-lg min-w-[250px] shadow-lg border-2 border-amber-800 transition-all duration-300 hover:shadow-xl z-20">
    <div class="absolute -top-2 -left-2 w-4 h-4 border-t-2 border-l-2 border-amber-600"></div>
    <div class="absolute -top-2 -right-2 w-4 h-4 border-t-2 border-r-2 border-amber-600"></div>
    <div class="absolute -bottom-2 -left-2 w-4 h-4 border-b-2 border-l-2 border-amber-600"></div>
    <div class="absolute -bottom-2 -right-2 w-4 h-4 border-b-2 border-r-2 border-amber-600"></div>
    
    <h2 class="text-2xl border-b-2 border-amber-600 pb-2 mb-3 font-bold text-amber-200 text-center font-serif">Knowledge Scroll</h2>
    <div id="unitInfo" class="text-sm text-amber-100">
      <div class="flex justify-center mb-3">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-amber-400 animate-bounce" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
      </div>
      <p class="text-center">Select a unit or building</p>
    </div>
  </div>
  
  <!-- Building Menu -->
  <div id="buildingMenu" class="absolute bottom-5 left-1/2 transform -translate-x-1/2 bg-stone-900 bg-opacity-90 text-amber-50 p-4 rounded-lg shadow-lg border-2 border-amber-800 flex space-x-4 z-20 hidden">
    <button class="building-btn w-16 h-16 bg-stone-800 hover:bg-stone-700 rounded-lg flex flex-col items-center justify-center border-2 border-amber-700 transition-all duration-200" data-building="house">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-amber-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>
      <span class="text-xs mt-1">House</span>
    </button>
    <button class="building-btn w-16 h-16 bg-stone-800 hover:bg-stone-700 rounded-lg flex flex-col items-center justify-center border-2 border-amber-700 transition-all duration-200" data-building="farm">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-amber-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
      </svg>
      <span class="text-xs mt-1">Farm</span>
    </button>
    <button class="building-btn w-16 h-16 bg-stone-800 hover:bg-stone-700 rounded-lg flex flex-col items-center justify-center border-2 border-amber-700 transition-all duration-200" data-building="quarry">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-amber-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
      </svg>
      <span class="text-xs mt-1">Quarry</span>
    </button>
    <button class="building-btn w-16 h-16 bg-stone-800 hover:bg-stone-700 rounded-lg flex flex-col items-center justify-center border-2 border-amber-700 transition-all duration-200" data-building="lumbermill">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-amber-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10l-2 1m0 0l-2-1m2 1v2.5M20 7l-2 1m2-1l-2-1m2 1v2.5M14 4l-2-1-2 1M4 7l2-1M4 7l2 1M4 7v2.5M12 21l-2-1m2 1l2-1m-2 1v-2.5M6 18l-2-1v-2.5M18 18l2-1v-2.5" />
      </svg>
      <span class="text-xs mt-1">Lumber Mill</span>
    </button>
    <button class="building-btn w-16 h-16 bg-stone-800 hover:bg-stone-700 rounded-lg flex flex-col items-center justify-center border-2 border-amber-700 transition-all duration-200" data-building="barracks">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-amber-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
      </svg>
      <span class="text-xs mt-1">Barracks</span>
    </button>
    <button class="building-btn w-16 h-16 bg-stone-800 hover:bg-stone-700 rounded-lg flex flex-col items-center justify-center border-2 border-amber-700 transition-all duration-200" data-building="tower">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-amber-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
      </svg>
      <span class="text-xs mt-1">Tower</span>
    </button>
  </div>
  
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Sound Control Button -->
  <div id="soundControl" class="sound-control">
    <svg id="soundOnIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
    <svg id="soundOffIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;">
      <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
    </svg>
  </div>
  
  <script>
    // Get canvas and context
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // Resize canvas to fill the viewport
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    // Define huge world dimensions
    const worldWidth = 3000;
    const worldHeight = 3000;
    
    // Global game state
    let selectedUnit = null;
    let selectedBuilding = null;
    let terrainFeatures = [];
    let resourceNodes = [];
    const units = [];
    const buildings = [];
    const enemies = [];
    const movementMarkers = [];
    const projectiles = [];
    let globalTime = 0;
    let dayNightCycle = 0; // 0-1000, 0-250 day, 250-500 dusk, 500-750 night, 750-1000 dawn
    let currentDay = 1;
    let enemyWaveTimer = 0;
    let enemyWaveInterval = 2000; // Time between enemy waves
    let enemyWaveNumber = 0;
    let isWaveActive = false;
    let questState = {
      mainQuest: "Build a Town Hall to establish your settlement",
      mainQuestComplete: false,
      sideQuests: [],
      completedQuests: []
    };
    let townHallBuilt = false;
    
    // Resources
    let resources = {
      wood: 100,
      stone: 100,
      food: 100,
      population: 2,
      populationCap: 5
    };

    let settlementEstablished = false;
    
    // Territory system
    let territories = []; // Array of {x, y, radius}
    const TERRITORY_RADIUS = 300; // Base territory radius
    
    // Building costs
    const buildingCosts = {
      townhall: { wood: 50, stone: 50 },
      house: { wood: 30, stone: 10 },
      farm: { wood: 40, stone: 20 },
      quarry: { wood: 30, stone: 30 },
      lumbermill: { wood: 50, stone: 10 },
      barracks: { wood: 60, stone: 40 },
      tower: { wood: 40, stone: 60 },
      castle: { wood: 200, stone: 300 }
    };
    
    // Unit costs
    const unitCosts = {
      settler: { food: 50 },
      builder: { food: 60, wood: 20 },
      worker: { food: 40 },
      warrior: { food: 80, wood: 30 },
      archer: { food: 70, wood: 40 },
      knight: { food: 100, wood: 50, stone: 30 }
    };
    
    // Screen shake state
    let shakeTime = 0;
    let shakeDuration = 0;
    let shakeMagnitude = 0;
    
    // Camera for scrolling
    let camera = { x: 0, y: 0 };
    const scrollSpeed = 15;
    const keysPressed = {};
    
    // Building placement mode
    let buildingPlacementMode = false;
    let selectedBuildingType = null;
    
    // Sound system
    let soundEnabled = true;
    let audioContext = null;
    let masterGainNode = null;
    
    // Initialize audio context
    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGainNode = audioContext.createGain();
        masterGainNode.gain.value = 0.3; // Set overall volume
        masterGainNode.connect(audioContext.destination);
      } catch (e) {
        console.error("Web Audio API not supported:", e);
      }
    }
    
    // Sound generator functions
    function playSound(type) {
      if (!soundEnabled || !audioContext) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(masterGainNode);
      
      const currentTime = audioContext.currentTime;
      
      switch(type) {
        case 'click':
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(800, currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(400, currentTime + 0.1);
          gainNode.gain.setValueAtTime(0.3, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.1);
          break;
          
        case 'build':
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(200, currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(600, currentTime + 0.2);
          gainNode.gain.setValueAtTime(0.2, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.3);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.3);
          break;
          
        case 'attack':
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(150, currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(50, currentTime + 0.2);
          gainNode.gain.setValueAtTime(0.4, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.2);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.2);
          break;
          
        case 'damage':
          oscillator.type = 'triangle';
          oscillator.frequency.setValueAtTime(100, currentTime);
          gainNode.gain.setValueAtTime(0.5, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.1);
          break;
          
        case 'collect':
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(400, currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(800, currentTime + 0.1);
          gainNode.gain.setValueAtTime(0.2, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.2);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.2);
          break;
          
        case 'quest':
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(523.25, currentTime); // C5
          oscillator.frequency.setValueAtTime(659.25, currentTime + 0.1); // E5
          oscillator.frequency.setValueAtTime(783.99, currentTime + 0.2); // G5
          gainNode.gain.setValueAtTime(0.3, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.5);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.5);
          break;
          
        case 'victory':
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(523.25, currentTime); // C5
          oscillator.frequency.setValueAtTime(659.25, currentTime + 0.1); // E5
          oscillator.frequency.setValueAtTime(783.99, currentTime + 0.2); // G5
          oscillator.frequency.setValueAtTime(1046.50, currentTime + 0.3); // C6
          gainNode.gain.setValueAtTime(0.3, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 1);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 1);
          break;
          
        case 'defeat':
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(300, currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(100, currentTime + 0.5);
          gainNode.gain.setValueAtTime(0.3, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.5);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.5);
          break;
          
        case 'move':
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(600, currentTime);
          gainNode.gain.setValueAtTime(0.1, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.05);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.05);
          break;
          
        case 'select':
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(700, currentTime);
          gainNode.gain.setValueAtTime(0.2, currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
          oscillator.start(currentTime);
          oscillator.stop(currentTime + 0.1);
          break;
      }
    }
    
    // Sound control button
    document.getElementById('soundControl').addEventListener('click', function() {
      soundEnabled = !soundEnabled;
      document.getElementById('soundOnIcon').style.display = soundEnabled ? 'block' : 'none';
      document.getElementById('soundOffIcon').style.display = soundEnabled ? 'none' : 'block';
      playSound('click');
    });
    
    // Optimized Particle System
    class ParticleSystem {
      constructor(maxParticles = 200) {
        this.particles = [];
        this.maxParticles = maxParticles;
        this.activeParticles = 0;
        this.nextFreeIndex = 0;
        
        // Pre-allocate particle objects
        for (let i = 0; i < this.maxParticles; i++) {
          this.particles.push({
            x: 0, y: 0,
            vx: 0, vy: 0,
            size: 0,
            lifetime: 0,
            maxLifetime: 0,
            color: '',
            type: '',
            active: false
          });
        }
      }
      
      createParticle(x, y, type) {
        if (this.activeParticles >= this.maxParticles) {
          return; // Skip if at max capacity
        }
        
        // Find next free particle
        let particle = this.particles[this.nextFreeIndex];
        particle.active = true;
        
        // Initialize particle based on type
        switch(type) {
          case 'dust':
            particle.x = x;
            particle.y = y;
            particle.vx = -0.5 + Math.random();
            particle.vy = -1 - Math.random();
            particle.size = 1 + Math.random() * 3;
            particle.lifetime = 30 + Math.random() * 30;
            particle.maxLifetime = particle.lifetime;
            particle.color = `rgba(210, 180, 140, 0.8)`;
            particle.type = 'dust';
            break;
            
          case 'smoke':
            particle.x = x;
            particle.y = y;
            particle.vx = -0.2 + Math.random() * 0.4;
            particle.vy = -0.5 - Math.random() * 0.5;
            particle.size = 3 + Math.random() * 5;
            particle.lifetime = 60 + Math.random() * 40;
            particle.maxLifetime = particle.lifetime;
            particle.color = `rgba(100, 100, 100, 0.7)`;
            particle.type = 'smoke';
            break;
            
          case 'sparkle':
            particle.x = x;
            particle.y = y;
            particle.vx = -1 + Math.random() * 2;
            particle.vy = -1 - Math.random() * 2;
            particle.size = 2 + Math.random() * 4;
            particle.lifetime = 20 + Math.random() * 20;
            particle.maxLifetime = particle.lifetime;
            particle.color = `rgba(255, 215, 0, 0.8)`;
            particle.type = 'sparkle';
            break;
            
          case 'blood':
            particle.x = x;
            particle.y = y;
            particle.vx = -1 + Math.random() * 2;
            particle.vy = -1 - Math.random() * 2;
            particle.size = 2 + Math.random() * 3;
            particle.lifetime = 40 + Math.random() * 20;
            particle.maxLifetime = particle.lifetime;
            particle.color = `rgba(180, 30, 30, 0.8)`;
            particle.type = 'blood';
            break;
        }
        
        this.activeParticles++;
        this.nextFreeIndex = (this.nextFreeIndex + 1) % this.maxParticles;
      }
      
      update() {
        for (let i = 0; i < this.maxParticles; i++) {
          const particle = this.particles[i];
          if (!particle.active) continue;
          
          // Update particle
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.lifetime--;
          
          // Apply gravity to certain types
          if (particle.type === 'blood' || particle.type === 'dust') {
            particle.vy += 0.1;
          }
          
          // Deactivate if lifetime expired
          if (particle.lifetime <= 0) {
            particle.active = false;
            this.activeParticles--;
          }
        }
      }
      
      draw(ctx) {
        for (let i = 0; i < this.maxParticles; i++) {
          const particle = this.particles[i];
          if (!particle.active) continue;
          
          const alpha = particle.lifetime / particle.maxLifetime;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = particle.color;
          
          if (particle.type === 'sparkle') {
            // Draw star shape for sparkles
            ctx.translate(particle.x, particle.y);
            ctx.beginPath();
            for (let j = 0; j < 5; j++) {
              const angle = (j / 5) * Math.PI * 2;
              const outerRadius = particle.size;
              const innerRadius = particle.size * 0.5;
              ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
              ctx.lineTo(Math.cos(angle + Math.PI / 5) * innerRadius, Math.sin(angle + Math.PI / 5) * innerRadius);
            }
            ctx.closePath();
            ctx.fill();
          } else {
            // Draw circle for other types
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.restore();
        }
      }
      
      createBurst(x, y, type, count) {
        for (let i = 0; i < count; i++) {
          this.createParticle(x, y, type);
        }
      }
    }
    
    // Create particle system instance
    const particleSystem = new ParticleSystem(200);
    
    function applyScreenShake(dt) {
      if (shakeTime > 0) {
        shakeTime -= dt;
        const progress = Math.max(shakeTime / shakeDuration, 0);
        const damper = progress * progress; // ease out curve
        const offsetX = (Math.random() * 2 - 1) * shakeMagnitude * damper;
        const offsetY = (Math.random() * 2 - 1) * shakeMagnitude * damper;
        camera.x += offsetX;
        camera.y += offsetY;
      }
    }
    
    function triggerShake(duration = 20, magnitude = 8) {
      shakeDuration = duration;
      shakeTime = duration;
      shakeMagnitude = magnitude;
    }
    
    // Textures and patterns
    const grassPattern = createGrassPattern();
    const dirtPattern = createDirtPattern();
    const stonePattern = createStonePattern();
    const woodPattern = createWoodPattern();
    
    // Add this near the top of your script
    const grassVariants = [];
    const GRASS_VARIANT_COUNT = 5;
    
    // Initialize grass variants
    function initGrassVariants() {
      for (let i = 0; i < GRASS_VARIANT_COUNT; i++) {
        grassVariants.push(createGrassPattern());
      }
    }
    
    // Modify the draw function to use grass variants
    function drawGrassBackground() {
      // Create a more natural grass background with multiple layers
      ctx.save();
      
      // Base layer
      ctx.fillStyle = grassVariants[0];
      ctx.fillRect(0, 0, worldWidth, worldHeight);
      
      // Add some variation by overlaying different grass patterns in patches
      for (let i = 0; i < 20; i++) {
        const x = Math.random() * worldWidth;
        const y = Math.random() * worldHeight;
        const width = 200 + Math.random() * 400;
        const height = 200 + Math.random() * 400;
        
        ctx.fillStyle = grassVariants[Math.floor(Math.random() * GRASS_VARIANT_COUNT)];
        ctx.globalAlpha = 0.3 + Math.random() * 0.4;
        ctx.fillRect(x, y, width, height);
      }
      
      ctx.globalAlpha = 1;
      ctx.restore();
    } 
    
    function createGrassPattern() {
      const PATTERN_SIZE = 256; // Increased from 64 to 256 for less repetition
      const patternCanvas = document.createElement('canvas');
      patternCanvas.width = PATTERN_SIZE;
      patternCanvas.height = PATTERN_SIZE;
      const pctx = patternCanvas.getContext('2d');
      
      // Create a more natural base with multiple color layers
      const baseColors = ['#2a5c45', '#2d6048', '#285842', '#2f5f4a', '#265340'];
      const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)];
      
      // Fill with base color
      pctx.fillStyle = baseColor;
      pctx.fillRect(0, 0, PATTERN_SIZE, PATTERN_SIZE);
      
      // Add subtle color variations across the pattern
      for (let i = 0; i < 5; i++) {
        const variationColor = `rgba(${Math.floor(Math.random() * 20) + 30}, ${Math.floor(Math.random() * 20) + 80}, ${Math.floor(Math.random() * 20) + 50}, 0.1)`;
        pctx.fillStyle = variationColor;
        
        // Create organic patches
        const patchX = Math.random() * PATTERN_SIZE;
        const patchY = Math.random() * PATTERN_SIZE;
        const patchSize = 50 + Math.random() * 100;
        
        const gradient = pctx.createRadialGradient(patchX, patchY, 0, patchX, patchY, patchSize);
        gradient.addColorStop(0, variationColor);
        gradient.addColorStop(1, 'transparent');
        
        pctx.fillStyle = gradient;
        pctx.fillRect(0, 0, PATTERN_SIZE, PATTERN_SIZE);
      }
      
      // Draw grass blades with more natural distribution
      const GRASS_BLADES_COUNT = 800; // Increased from 100 to 800
      const BLADE_COLORS = ['#3a7d56', '#4a8d66', '#2e6d46', '#357550', '#428a5f'];
      
      for (let i = 0; i < GRASS_BLADES_COUNT; i++) {
        const x = Math.random() * PATTERN_SIZE;
        const y = Math.random() * PATTERN_SIZE;
        
        // Vary grass blade properties more naturally
        const height = 2 + Math.random() * 6;
        const angle = -0.4 + Math.random() * 0.8;
        const width = 0.3 + Math.random() * 1.2;
        const colorIndex = Math.floor(Math.random() * BLADE_COLORS.length);
        const color = BLADE_COLORS[colorIndex];
        
        // Add some transparency variation
        const alpha = 0.6 + Math.random() * 0.4;
        
        pctx.strokeStyle = color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        pctx.lineWidth = width;
        pctx.lineCap = 'round';
        
        pctx.beginPath();
        pctx.moveTo(x, y);
        
        // Create more natural grass blade curve
        const controlX = x + Math.sin(angle) * height * 0.5;
        const controlY = y - Math.cos(angle) * height * 0.3;
        const endX = x + Math.sin(angle) * height;
        const endY = y - Math.cos(angle) * height;
        
        pctx.quadraticCurveTo(controlX, controlY, endX, endY);
        pctx.stroke();
        
        // Add some grass blades with multiple segments for more detail
        if (Math.random() > 0.7) {
          pctx.beginPath();
          pctx.moveTo(endX, endY);
          pctx.lineTo(endX + Math.sin(angle + 0.3) * height * 0.4, endY - Math.cos(angle + 0.3) * height * 0.4);
          pctx.stroke();
        }
      }
      
      // Add more flowers and details with better distribution
      const FLOWER_TYPES = [
        { colors: ['#ff6b6b', '#feca57', '#5f27cd', '#ff9ff3', '#1dd1a1'], size: 2.5, count: 15 },
        { colors: ['#ff7675', '#fd79a8', '#e84393', '#f368e0'], size: 2, count: 10 },
        { colors: ['#ffeaa7', '#fdcb6e', '#e17055', '#d63031'], size: 1.8, count: 12 },
        { colors: ['#a29bfe', '#6c5ce7', '#5f3dc4', '#341f97'], size: 2.2, count: 8 }
      ];
      
      FLOWER_TYPES.forEach(flowerType => {
        for (let i = 0; i < flowerType.count; i++) {
          // Create small clusters of flowers
          const clusterSize = Math.random() > 0.8 ? 2 + Math.floor(Math.random() * 3) : 1;
          const baseX = Math.random() * PATTERN_SIZE;
          const baseY = Math.random() * PATTERN_SIZE;
          const color = flowerType.colors[Math.floor(Math.random() * flowerType.colors.length)];
          
          for (let j = 0; j < clusterSize; j++) {
            const x = baseX + (Math.random() - 0.5) * 15;
            const y = baseY + (Math.random() - 0.5) * 15;
            const size = flowerType.size * (0.8 + Math.random() * 0.4);
            
            // Draw flower petals
            pctx.fillStyle = color;
            pctx.beginPath();
            
            // Draw 5 petals in a circle
            for (let k = 0; k < 5; k++) {
              const angle = (k / 5) * Math.PI * 2;
              const petalX = x + Math.cos(angle) * size * 0.8;
              const petalY = y + Math.sin(angle) * size * 0.8;
              
              pctx.moveTo(x, y);
              pctx.quadraticCurveTo(
                x + Math.cos(angle - 0.3) * size * 0.6,
                y + Math.sin(angle - 0.3) * size * 0.6,
                petalX,
                petalY
              );
              pctx.quadraticCurveTo(
                x + Math.cos(angle + 0.3) * size * 0.6,
                y + Math.sin(angle + 0.3) * size * 0.6,
                x,
                y
              );
            }
            
            pctx.fill();
            
            // Add flower center
            if (size > 2) {
              pctx.fillStyle = '#f6e58d';
              pctx.beginPath();
              pctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
              pctx.fill();
              
              // Add detail to center
              pctx.fillStyle = '#e1b12c';
              pctx.beginPath();
              pctx.arc(x, y, size * 0.15, 0, Math.PI * 2);
              pctx.fill();
            }
          }
        }
      });
      
      // Add some small rocks and debris for more natural look
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * PATTERN_SIZE;
        const y = Math.random() * PATTERN_SIZE;
        const size = 1 + Math.random() * 3;
        
        // Rock colors
        const rockColors = ['#8b7355', '#a0826d', '#696969', '#778899'];
        const rockColor = rockColors[Math.floor(Math.random() * rockColors.length)];
        
        pctx.fillStyle = rockColor;
        pctx.beginPath();
        pctx.arc(x, y, size, 0, Math.PI * 2);
        pctx.fill();
        
        // Add highlight
        pctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        pctx.beginPath();
        pctx.arc(x - size * 0.3, y - size * 0.3, size * 0.3, 0, Math.PI * 2);
        pctx.fill();
      }
      
      // Add some texture noise to break up the pattern
      const imageData = pctx.getImageData(0, 0, PATTERN_SIZE, PATTERN_SIZE);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        // Add subtle noise to RGB channels
        const noise = (Math.random() - 0.5) * 10;
        data[i] = Math.max(0, Math.min(255, data[i] + noise));     // Red
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // Green
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // Blue
      }
      
      pctx.putImageData(imageData, 0, 0);
      
      return ctx.createPattern(patternCanvas, 'repeat');
    }
    
    function createDirtPattern() {
      const SIZE = 64; // Larger pattern size for more variation
      const patternCanvas = document.createElement('canvas');
      patternCanvas.width = SIZE;
      patternCanvas.height = SIZE;
      const pctx = patternCanvas.getContext('2d');
      
      // Base dirt colors with subtle gradient
      const gradient = pctx.createLinearGradient(0, 0, SIZE, SIZE);
      gradient.addColorStop(0, '#6b5543');
      gradient.addColorStop(0.5, '#5e4a3a');
      gradient.addColorStop(1, '#4f3d30');
      pctx.fillStyle = gradient;
      pctx.fillRect(0, 0, SIZE, SIZE);
      
      // Create dirt clumps and cracks
      pctx.strokeStyle = '#4f3d30';
      pctx.lineWidth = 1.5;
      
      // Organic-looking cracks
      for (let i = 0; i < 12; i++) {
        pctx.beginPath();
        let x = Math.random() * SIZE;
        let y = Math.random() * SIZE;
        pctx.moveTo(x, y);
        
        // Create jagged crack path
        for (let j = 0; j < 3 + Math.floor(Math.random() * 4); j++) {
          x += (Math.random() - 0.3) * 15;
          y += (Math.random() - 0.3) * 15;
          pctx.lineTo(
            Math.max(0, Math.min(SIZE, x)),
            Math.max(0, Math.min(SIZE, y))
          );
        }
        pctx.stroke();
      }
      
      // Dirt clumps with texture
      for (let i = 0; i < 25; i++) {
        const x = Math.random() * SIZE;
        const y = Math.random() * SIZE;
        const width = 5 + Math.random() * 10;
        const height = 3 + Math.random() * 6;
        
        // Draw organic-shaped clump
        pctx.fillStyle = `rgba(90, 70, 50, ${0.2 + Math.random() * 0.3})`;
        pctx.beginPath();
        pctx.ellipse(
          x, y, 
          width * 0.5, height * 0.5,
          Math.random() * Math.PI,
          0, Math.PI * 2
        );
        pctx.fill();
        
        // Add texture to clump
        pctx.strokeStyle = `rgba(70, 50, 40, ${0.3 + Math.random() * 0.3})`;
        pctx.beginPath();
        for (let j = 0; j < 5 + Math.random() * 5; j++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * width * 0.4;
          pctx.moveTo(x, y);
          pctx.lineTo(
            x + Math.cos(angle) * radius,
            y + Math.sin(angle) * radius
          );
        }
        pctx.stroke();
      }
      
      // Subtle pebbles/stones
      for (let i = 0; i < 40; i++) {
        const x = Math.random() * SIZE;
        const y = Math.random() * SIZE;
        const size = 0.5 + Math.random() * 2;
        
        pctx.fillStyle = `rgba(120, 100, 80, ${0.5 + Math.random() * 0.3})`;
        pctx.beginPath();
        pctx.arc(x, y, size, 0, Math.PI * 2);
        pctx.fill();
        
        // Add highlight to pebbles
        if (size > 1) {
          pctx.fillStyle = `rgba(180, 160, 140, 0.3)`;
          pctx.beginPath();
          pctx.arc(
            x - size * 0.3, 
            y - size * 0.3, 
            size * 0.3, 
            0, 
            Math.PI * 2
          );
          pctx.fill();
        }
      }
      
      return ctx.createPattern(patternCanvas, 'repeat');
    }
    
    function createStonePattern() {
      const patternCanvas = document.createElement('canvas');
      patternCanvas.width = 32;
      patternCanvas.height = 32;
      const pctx = patternCanvas.getContext('2d');
      
      // Base stone color
      pctx.fillStyle = '#6b7280';
      pctx.fillRect(0, 0, 32, 32);
      
      // Add stone texture
      pctx.strokeStyle = '#9ca3af';
      pctx.lineWidth = 1;
      for (let i = 0; i < 20; i++) {
        const x = Math.random() * 32;
        const y = Math.random() * 32;
        const length = 5 + Math.random() * 10;
        const angle = Math.random() * Math.PI * 2;
        pctx.beginPath();
        pctx.moveTo(x, y);
        pctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
        pctx.stroke();
      }
      
      return ctx.createPattern(patternCanvas, 'repeat');
    }
    
    function createWoodPattern() {
      const patternCanvas = document.createElement('canvas');
      patternCanvas.width = 64;
      patternCanvas.height = 64;
      const pctx = patternCanvas.getContext('2d');
      
      // Base wood color
      pctx.fillStyle = '#6b4226';
      pctx.fillRect(0, 0, 64, 64);
      
      // Add wood grain
      pctx.strokeStyle = '#8B4513';
      pctx.lineWidth = 2;
      for (let i = 0; i < 10; i++) {
        const y = i * 6 + Math.random() * 3;
        pctx.beginPath();
        pctx.moveTo(0, y);
        for (let x = 0; x < 64; x += 5) {
          pctx.lineTo(x, y + Math.sin(x / 10) * 2);
        }
        pctx.stroke();
      }
      
      return ctx.createPattern(patternCanvas, 'repeat');
    }
    
    // Add this at the top of your script with other global variables
    let customCursor = {
      x: 0,
      y: 0,
      visible: true,
      type: 'default' // 'default', 'build', 'attack', 'gather'
    };
    
    // Add this after the canvas initialization
    canvas.style.cursor = 'none'; // Hide default cursor
    
    // Add this mousemove event listener to track cursor position
    canvas.addEventListener('mousemove', function(e) {
      const rect = canvas.getBoundingClientRect();
      customCursor.x = e.clientX - rect.left;
      customCursor.y = e.clientY - rect.top;
    });
    
    // Add this to handle cursor visibility when leaving/entering canvas
    canvas.addEventListener('mouseenter', () => customCursor.visible = true);
    canvas.addEventListener('mouseleave', () => customCursor.visible = false);
    
    // Add this function to determine cursor type based on context
    function updateCursorType() {
      if (buildingPlacementMode) {
        customCursor.type = 'build';
        return;
      }
      
      if (!selectedUnit) {
        customCursor.type = 'default';
        return;
      }
      
      // Convert mouse position to world coordinates
      const worldMouseX = customCursor.x + camera.x;
      const worldMouseY = customCursor.y + camera.y;
      
      // Check if hovering over enemy
      for (const enemy of enemies) {
        const dist = Math.hypot(enemy.x - worldMouseX, enemy.y - worldMouseY);
        if (dist <= enemy.radius + 10) {
          customCursor.type = 'attack';
          return;
        }
      }
      
      // Check if hovering over resource (for workers)
      if (selectedUnit.type === 'worker') {
        for (const resource of resourceNodes) {
          const dist = Math.hypot(resource.x - worldMouseX, resource.y - worldMouseY);
          if (dist <= resource.radius && resource.amount > 0) {
            customCursor.type = 'gather';
            return;
          }
        }
      }
      
      customCursor.type = 'default';
    }
    
    // Add this function to draw the custom cursor
    function drawCustomCursor() {
      if (!customCursor.visible) return;
      
      ctx.save();
      
      // Update cursor type based on context
      updateCursorType();
      
      // Set cursor appearance based on type
      switch(customCursor.type) {
        case 'build':
          drawBuildCursor();
          break;
        case 'attack':
          drawAttackCursor();
          break;
        case 'gather':
          drawGatherCursor();
          break;
        default:
          drawDefaultCursor();
      }
      
      ctx.restore();
    }
    
    // Cursor drawing functions
    function drawDefaultCursor() {
      const size = 12;
      const x = customCursor.x;
      const y = customCursor.y;
      
      // Medieval pointer design
      ctx.strokeStyle = '#fcd34d';
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      
      // Main pointer
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + size, y);
      ctx.lineTo(x + size/2, y + size/2);
      ctx.closePath();
      ctx.stroke();
      
      // Cross detail
      ctx.beginPath();
      ctx.moveTo(x + size/3, y + size/3);
      ctx.lineTo(x + size*2/3, y + size*2/3);
      ctx.stroke();
      
      // Glow effect
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(252, 211, 77, 0.5)';
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    function drawBuildCursor() {
      const size = 20;
      const { x, y } = customCursor;

      ctx.save();

      // Shadow glow
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(245, 158, 11, 0.6)';

      // Handle
      ctx.fillStyle = '#8B4513'; // richer brown
      ctx.strokeStyle = '#5a2d0c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(x - 3, y - size / 2, 6, size, 2);
      ctx.fill();
      ctx.stroke();

      // Hammer head (metallic look)
      const headW = size;
      const headH = size / 3;
      const headX = x - headW / 2;
      const headY = y - size / 2;

      const grad = ctx.createLinearGradient(headX, headY, headX + headW, headY + headH);
      grad.addColorStop(0, '#d4af37');
      grad.addColorStop(0.5, '#facc15');
      grad.addColorStop(1, '#d97706');

      ctx.fillStyle = grad;
      ctx.strokeStyle = '#78350f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(headX, headY, headW, headH, 3);
      ctx.fill();
      ctx.stroke();

      // Small highlight line on the head
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath();
      ctx.moveTo(headX + 3, headY + 3);
      ctx.lineTo(headX + headW - 3, headY + 3);
      ctx.stroke();

      // Reset glow
      ctx.shadowBlur = 0;

      ctx.restore();
    }
    
    function drawAttackCursor() {
      const size = 14;
      const x = customCursor.x;
      const y = customCursor.y;
      
      // Sword design
      ctx.strokeStyle = '#ef4444';
      ctx.fillStyle = '#a1a1aa';
      ctx.lineWidth = 2;
      
      // Blade
      ctx.fillRect(x - 1, y - size, 2, size);
      
      // Guard
      ctx.fillRect(x - size/3, y - size/3, size*2/3, 2);
      
      // Handle
      ctx.fillRect(x - 1, y, 2, size/3);
      
      // Outline
      ctx.strokeRect(x - 1, y - size, 2, size);
      
      // Blood drops
      ctx.fillStyle = '#991b1b';
      ctx.beginPath();
      ctx.arc(x + 3, y - size/2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Glow effect
      ctx.shadowBlur = 12;
      ctx.shadowColor = 'rgba(239, 68, 68, 0.6)';
      ctx.strokeRect(x - 1, y - size, 2, size);
      ctx.shadowBlur = 0;
    }
    
    function drawGatherCursor() {
      const size = 14;
      const x = customCursor.x;
      const y = customCursor.y;
      
      // Pickaxe design
      ctx.strokeStyle = '#3b82f6';
      ctx.fillStyle = '#a1a1aa';
      ctx.lineWidth = 2;
      
      // Handle
      ctx.fillRect(x - 1, y - size/2, 2, size);
      
      // Head
      ctx.beginPath();
      ctx.moveTo(x - size/2, y - size/3);
      ctx.lineTo(x + size/2, y - size/3);
      ctx.lineTo(x + size/3, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Glow effect
      ctx.shadowBlur = 12;
      ctx.shadowColor = 'rgba(59, 130, 246, 0.6)';
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Resource Node class
    class ResourceNode {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'tree', 'rock', 'bush'
        this.amount = type === 'tree' ? 100 : type === 'rock' ? 80 : 50;
        this.maxAmount = this.amount;
        this.radius = type === 'tree' ? 20 : type === 'rock' ? 15 : 10;
        this.respawnTimer = 0;
        this.respawnTime = type === 'tree' ? 500 : type === 'rock' ? 700 : 300;
        this.assignedWorkers = []; // Workers assigned to this resource
        
        // Enhanced visual properties
        this.gatheringEffect = 0;
        this.depleted = false;
        this.animationOffset = Math.random() * Math.PI * 2;
        this.windSway = 0;
        this.hasBeenHarvested = false; // Track if resource has been harvested
        
        // Pre-calculate visual properties for rocks to prevent flickering
        if (type === 'rock') {
          this.rotation = Math.random() * Math.PI * 2;
          this.rockPoints = this.generateRockPoints();
          this.facetPositions = this.generateFacetPositions();
          this.crackPoints = this.generateCrackPoints();
          this.textureDots = this.generateTextureDots();
        }
        
        // Bush visual variety
        if (type === 'bush') {
          this.berryPositions = this.generateBerryPositions();
          this.leafClusters = this.generateLeafClusters();
        }
      }
      
      // Helper methods for generating rock visual properties
      generateRockPoints() {
        const points = 8;
        const shapePoints = [];
        for (let i = 0; i < points; i++) {
          const angle = (i / points) * Math.PI * 2;
          const radiusVariation = 0.8 + Math.sin(i * 1.7) * 0.2;
          const x = Math.cos(angle) * this.radius * radiusVariation;
          const y = Math.sin(angle) * this.radius * radiusVariation;
          shapePoints.push({ x, y });
        }
        return shapePoints;
      }
      
      generateFacetPositions() {
        return [
          { 
            x: -this.radius * (0.2 + Math.random() * 0.2), 
            y: -this.radius * (0.1 + Math.random() * 0.2), 
            size: this.radius * (0.3 + Math.random() * 0.2) 
          },
          { 
            x: this.radius * (0.1 + Math.random() * 0.2), 
            y: -this.radius * (0.2 + Math.random() * 0.2), 
            size: this.radius * (0.25 + Math.random() * 0.2) 
          },
          { 
            x: this.radius * (0.05 + Math.random() * 0.15), 
            y: this.radius * (0.2 + Math.random() * 0.2), 
            size: this.radius * (0.2 + Math.random() * 0.2) 
          },
          { 
            x: -this.radius * (0.1 + Math.random() * 0.2), 
            y: this.radius * (0.05 + Math.random() * 0.15), 
            size: this.radius * (0.15 + Math.random() * 0.2) 
          }
        ];
      }
      
      generateCrackPoints() {
        return {
          main: {
            start: { 
              x: -this.radius * (0.15 + Math.random() * 0.1), 
              y: -this.radius * (0.3 + Math.random() * 0.2) 
            },
            control: { 
              x: (Math.random() - 0.5) * this.radius * 0.4, 
              y: (Math.random() - 0.5) * this.radius * 0.4 
            },
            end: { 
              x: this.radius * (0.2 + Math.random() * 0.2), 
              y: this.radius * (0.2 + Math.random() * 0.2) 
            }
          },
          secondary1: {
            start: { 
              x: this.radius * (0.3 + Math.random() * 0.2), 
              y: -this.radius * (0.05 + Math.random() * 0.1) 
            },
            end: { 
              x: this.radius * (0.05 + Math.random() * 0.1), 
              y: this.radius * (0.15 + Math.random() * 0.1) 
            }
          },
          secondary2: {
            start: { 
              x: -this.radius * (0.2 + Math.random() * 0.2), 
              y: this.radius * (0.05 + Math.random() * 0.1) 
            },
            end: { 
              x: -this.radius * (0.05 + Math.random() * 0.1), 
              y: -this.radius * (0.15 + Math.random() * 0.1) 
            }
          }
        };
      }
      
      generateTextureDots() {
        const dots = [];
        const dotCount = 8;
        for (let i = 0; i < dotCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * this.radius * 0.7;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          const size = 0.5 + Math.random() * 1.5;
          dots.push({ x, y, size });
        }
        return dots;
      }
      
      // Helper methods for bush visual properties
      generateBerryPositions() {
        const berries = [];
        const berryCount = 12 + Math.floor(Math.random() * 8);
        for (let i = 0; i < berryCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * this.radius * 0.8;
          berries.push({
            x: Math.cos(angle) * distance,
            y: Math.sin(angle) * distance,
            size: 1.5 + Math.random() * 1,
            color: Math.random() > 0.7 ? '#FF6347' : '#DC143C' // Mix of red shades
          });
        }
        return berries;
      }
      
      generateLeafClusters() {
        const clusters = [];
        const clusterCount = 5 + Math.floor(Math.random() * 3);
        for (let i = 0; i < clusterCount; i++) {
          const angle = (i / clusterCount) * Math.PI * 2 + Math.random() * 0.5;
          const distance = this.radius * (0.3 + Math.random() * 0.4);
          clusters.push({
            x: Math.cos(angle) * distance,
            y: Math.sin(angle) * distance,
            size: this.radius * (0.4 + Math.random() * 0.3),
            color: `hsl(${100 + Math.random() * 40}, 70%, ${30 + Math.random() * 20}%)`
          });
        }
        return clusters;
      }
      
      gather(amount) {
        const gathered = Math.min(amount, this.amount);
        this.amount -= gathered;
        this.gatheringEffect = 10; // Show gathering effect for 10 frames
        this.hasBeenHarvested = true; // Mark as harvested
        
        if (this.amount <= 0) {
          this.depleted = true;
          this.respawnTimer = this.respawnTime;
        }
        
        return gathered;
      }
      
      update() {
        // Update gathering effect
        if (this.gatheringEffect > 0) {
          this.gatheringEffect--;
        }
        
        // Update wind sway for trees
        this.windSway = Math.sin(globalTime * 0.02 + this.animationOffset) * 2;
        
        // Handle respawning
        if (this.depleted && this.respawnTimer > 0) {
          this.respawnTimer--;
          if (this.respawnTimer <= 0) {
            // Respawn at a new random location
            this.x = 100 + Math.random() * (worldWidth - 200);
            this.y = 100 + Math.random() * (worldHeight - 200);
            this.amount = this.maxAmount;
            this.depleted = false;
            this.hasBeenHarvested = false; // Reset harvest state
            
            // Clear assigned workers since the resource moved
            this.assignedWorkers = [];
            
            // Add respawn particles at the new location
            particleSystem.createBurst(this.x, this.y, 'sparkle', 15);
          }
        }
        
        return true;
      }
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw depleted state if needed
        if (this.depleted) {
          this.drawDepletedState(ctx);
          ctx.restore();
          return;
        }
        
        // Draw resource based on type
        if (this.type === 'tree') {
          this.drawTree(ctx);
          // Draw health bar only if harvested
          if (this.hasBeenHarvested) {
            this.drawHealthBar(ctx);
          }
        } else if (this.type === 'rock') {
          ctx.save(); // Save before drawing rock
          this.drawRock(ctx);
          ctx.restore(); // Restore after drawing rock
          
          // Draw health bar only if harvested
          if (this.hasBeenHarvested) {
            this.drawHealthBar(ctx);
          }
        } else if (this.type === 'bush') {
          this.drawBush(ctx);
          // Draw health bar only if harvested
          if (this.hasBeenHarvested) {
            this.drawHealthBar(ctx);
          }
        }
        
        // Draw gathering effect
        if (this.gatheringEffect > 0) {
          this.drawGatheringEffect(ctx);
        }
        
        // Show assigned workers count
        if (this.assignedWorkers.length > 0) {
          ctx.fillStyle = '#3b82f6';
          ctx.font = '12px MedievalSharp, cursive';
          ctx.textAlign = 'center';
          const yOffset = this.type === 'tree' ? -this.radius * 2.5 : 
                          this.type === 'rock' ? -this.radius - 15 : 
                          -this.radius - 10;
          ctx.fillText(`${this.assignedWorkers.length}`, 0, yOffset);
        }
        
        ctx.restore();
      }
       
      drawDepletedState(ctx) {
        if (this.type === 'tree') {
          // Draw tree stump
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(-this.radius * 0.3, -5, this.radius * 0.6, 10);
          
          // Stump rings
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 1;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.ellipse(0, -3 + i * 3, this.radius * 0.25, 1, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          // Small sprout
          if (this.respawnTimer < this.respawnTime * 0.5) {
            ctx.fillStyle = '#2E8B57';
            ctx.beginPath();
            ctx.arc(0, -8, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (this.type === 'rock') {
          // Draw small rock fragments
          ctx.fillStyle = '#808080';
          for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const dist = this.radius * 0.3;
            const size = this.radius * (0.2 + Math.random() * 0.2);
            ctx.beginPath();
            ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, size, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (this.type === 'bush') {
          // Draw withered bush
          ctx.fillStyle = '#8B7355';
          for (let i = 0; i < 3; i++) {
            const angle = (i / 3) * Math.PI * 2;
            const dist = this.radius * 0.4;
            ctx.beginPath();
            ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, this.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      drawTree(ctx) {
        // Apply wind sway
        ctx.save();
        ctx.translate(this.windSway, 0);
        
        // Tree shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(0, this.radius * 0.1, this.radius * 0.8, this.radius * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Tree trunk with texture
        const trunkHeight = this.radius * 1.8;
        const trunkWidth = this.radius * 0.3;
        const trunkTopWidth = trunkWidth * 0.6;
        
        // Main trunk with gradient
        const trunkGradient = ctx.createLinearGradient(-trunkWidth/2, 0, trunkWidth/2, 0);
        trunkGradient.addColorStop(0, '#8B4513');
        trunkGradient.addColorStop(0.5, '#A0522D');
        trunkGradient.addColorStop(1, '#8B4513');
        
        ctx.fillStyle = trunkGradient;
        ctx.beginPath();
        ctx.moveTo(-trunkWidth/2, 0);
        ctx.lineTo(trunkWidth/2, 0);
        ctx.lineTo(trunkTopWidth/2, -trunkHeight);
        ctx.lineTo(-trunkTopWidth/2, -trunkHeight);
        ctx.closePath();
        ctx.fill();
        
        // Trunk texture lines
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
          const offset = (i - 1.5) * trunkWidth * 0.25;
          ctx.beginPath();
          ctx.moveTo(offset, 0);
          ctx.lineTo(offset * 0.7, -trunkHeight);
          ctx.stroke();
        }
        
        // Tree roots
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-trunkWidth/2, 0);
        ctx.lineTo(-trunkWidth, trunkHeight * 0.2);
        ctx.moveTo(trunkWidth/2, 0);
        ctx.lineTo(trunkWidth, trunkHeight * 0.2);
        ctx.stroke();
        
        // Foliage layers for depth
        const foliageColors = ['#2E8B57', '#228B22', '#3CB371', '#2F4F2F'];
        
        // Back foliage layer
        ctx.fillStyle = foliageColors[0];
        ctx.beginPath();
        ctx.arc(0, -trunkHeight - this.radius * 0.6, this.radius * 1.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Middle foliage layers
        ctx.fillStyle = foliageColors[1];
        ctx.beginPath();
        ctx.arc(-this.radius * 0.4, -trunkHeight - this.radius * 0.4, this.radius * 1.0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = foliageColors[2];
        ctx.beginPath();
        ctx.arc(this.radius * 0.4, -trunkHeight - this.radius * 0.4, this.radius * 1.0, 0, Math.PI * 2);
        ctx.fill();
        
        // Front foliage layer
        ctx.fillStyle = foliageColors[3];
        ctx.beginPath();
        ctx.arc(0, -trunkHeight - this.radius * 0.8, this.radius * 1.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Foliage highlights
        ctx.fillStyle = 'rgba(144, 238, 144, 0.4)';
        ctx.beginPath();
        ctx.arc(-this.radius * 0.2, -trunkHeight - this.radius * 0.9, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(this.radius * 0.3, -trunkHeight - this.radius * 0.7, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      drawRock(ctx) {
        // Apply rotation for variety
        ctx.rotate(this.rotation);
        
        // Rock shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.beginPath();
        ctx.ellipse(2, 2, this.radius * 0.9, this.radius * 0.6, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Main rock body with irregular shape
        ctx.fillStyle = '#808080';
        ctx.beginPath();
        this.rockPoints.forEach((point, index) => {
          if (index === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        });
        ctx.closePath();
        ctx.fill();
        
        // Rock surface details
        const facetColors = ['#A9A9A9', '#C0C0C0', '#969696'];
        this.facetPositions.forEach((facet, index) => {
          ctx.fillStyle = facetColors[index % facetColors.length];
          ctx.beginPath();
          ctx.arc(facet.x, facet.y, facet.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Rock cracks
        ctx.strokeStyle = '#696969';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        
        // Main crack
        ctx.beginPath();
        ctx.moveTo(this.crackPoints.main.start.x, this.crackPoints.main.start.y);
        ctx.quadraticCurveTo(
          this.crackPoints.main.control.x, 
          this.crackPoints.main.control.y,
          this.crackPoints.main.end.x, 
          this.crackPoints.main.end.y
        );
        ctx.stroke();
        
        // Secondary cracks
        ctx.beginPath();
        ctx.moveTo(this.crackPoints.secondary1.start.x, this.crackPoints.secondary1.start.y);
        ctx.lineTo(this.crackPoints.secondary1.end.x, this.crackPoints.secondary1.end.y);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(this.crackPoints.secondary2.start.x, this.crackPoints.secondary2.start.y);
        ctx.lineTo(this.crackPoints.secondary2.end.x, this.crackPoints.secondary2.end.y);
        ctx.stroke();
        
        // Rock texture dots
        ctx.fillStyle = '#606060';
        this.textureDots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Highlights for 3D effect
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(this.radius * 0.2, -this.radius * 0.4, this.radius * 0.15, 0, Math.PI * 2);
        ctx.fill();
      }
      
      drawBush(ctx) {
        // Bush shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(0, this.radius * 0.2, this.radius * 0.9, this.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw leaf clusters
        this.leafClusters.forEach(cluster => {
          ctx.fillStyle = cluster.color;
          ctx.beginPath();
          ctx.arc(cluster.x, cluster.y, cluster.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Draw berries
        this.berryPositions.forEach(berry => {
          ctx.fillStyle = berry.color;
          ctx.beginPath();
          ctx.arc(berry.x, berry.y, berry.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Berry highlight
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.beginPath();
          ctx.arc(berry.x - berry.size * 0.3, berry.y - berry.size * 0.3, berry.size * 0.3, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Bush center
        ctx.fillStyle = '#228B22';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
      
      drawGatheringEffect(ctx) {
        const effectStrength = this.gatheringEffect / 10;
        
        if (this.type === 'tree') {
          // Wood chips flying off
          ctx.fillStyle = `rgba(139, 69, 19, ${effectStrength})`;
          for (let i = 0; i < 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * this.radius;
            const size = 1 + Math.random() * 2;
            ctx.beginPath();
            ctx.arc(
              Math.cos(angle) * dist, 
              Math.sin(angle) * dist - this.radius * 1.5, 
              size, 0, Math.PI * 2
            );
            ctx.fill();
          }
        } else if (this.type === 'rock') {
          // Stone chips flying off
          ctx.fillStyle = `rgba(128, 128, 128, ${effectStrength})`;
          for (let i = 0; i < 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * this.radius;
            const size = 1 + Math.random() * 2;
            ctx.beginPath();
            ctx.arc(
              Math.cos(angle) * dist, 
              Math.sin(angle) * dist, 
              size, 0, Math.PI * 2
            );
            ctx.fill();
          }
        } else if (this.type === 'bush') {
          // Leaves falling
          ctx.fillStyle = `rgba(34, 139, 34, ${effectStrength})`;
          for (let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * this.radius;
            ctx.beginPath();
            ctx.arc(
              Math.cos(angle) * dist, 
              Math.sin(angle) * dist - this.radius, 
              2, 0, Math.PI * 2
            );
            ctx.fill();
          }
        }
      }
      
      drawHealthBar(ctx) {
        const healthPercent = this.amount / this.maxAmount;
        const barWidth = 40;
        const barHeight = 6;
        
        // Position based on resource type with dynamic height adjustment
        let barY;
        if (this.type === 'tree') {
          barY = -this.radius * 2.8 - (1 - healthPercent) * 10; // Floats up as health decreases
        } else if (this.type === 'rock') {
          barY = -this.radius - 20;
        } else {
          barY = -this.radius - 15;
        }
        
        // Health bar background with border
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(-barWidth/2 - 2, barY - 2, barWidth + 4, barHeight + 4);
        
        // Health bar background
        ctx.fillStyle = 'rgba(30, 30, 30, 0.7)';
        ctx.fillRect(-barWidth/2, barY, barWidth, barHeight);
        
        // Health bar fill with gradient based on health level
        const gradient = ctx.createLinearGradient(-barWidth/2, 0, barWidth/2, 0);
        if (healthPercent > 0.6) {
          gradient.addColorStop(0, '#10b981');
          gradient.addColorStop(1, '#34d399');
        } else if (healthPercent > 0.3) {
          gradient.addColorStop(0, '#f59e0b');
          gradient.addColorStop(1, '#fcd34d');
        } else {
          gradient.addColorStop(0, '#ef4444');
          gradient.addColorStop(1, '#f87171');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(-barWidth/2, barY, barWidth * healthPercent, barHeight);
        
        // Health bar border
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.lineWidth = 1;
        ctx.strokeRect(-barWidth/2, barY, barWidth, barHeight);
        
        // Health percentage text
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px MedievalSharp, cursive';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(healthPercent * 100)}%`, 0, barY + barHeight/2);
        
        // Add warning indicator when health is low
        if (healthPercent <= 0.3) {
          const pulseAlpha = 0.5 + 0.5 * Math.sin(globalTime * 0.1);
          ctx.fillStyle = `rgba(239, 68, 68, ${pulseAlpha})`;
          ctx.beginPath();
          ctx.arc(0, barY - 10, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Warning text
          ctx.fillStyle = `rgba(239, 68, 68, ${pulseAlpha})`;
          ctx.font = 'bold 8px MedievalSharp, cursive';
          ctx.fillText('LOW', 0, barY - 15);
        }
        
        // Add resource type indicator
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '8px MedievalSharp, cursive';
        ctx.textAlign = 'center';
        const resourceIcon = this.type === 'tree' ? '🌲' : 
                            this.type === 'rock' ? '🪨' : '🌿';
        ctx.fillText(resourceIcon, 0, barY + barHeight + 10);
      }
    }  
    
    // Enemy class
    class Enemy {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'raider', 'wolf'
        this.radius = type === 'raider' ? 16 : 12;
        this.speed = type === 'raider' ? 1.5 : 2;
        this.health = type === 'raider' ? 80 : 50;
        this.maxHealth = this.health;
        this.damage = type === 'raider' ? 15 : 10;
        this.attackCooldown = 0;
        this.attackSpeed = 60; // Frames between attacks
        this.target = null;
        this.animationOffset = Math.random() * Math.PI * 2;
        
        // Enhanced animation properties
        this.walkCycle = 0;
        this.attackAnimation = 0;
        this.isMoving = false;
        this.facingDirection = 1; // 1 for right, -1 for left
        this.bloodParticles = [];
        this.impactEffect = 0;
        
        // Pre-calculate visual properties to prevent flickering
        this.visualVariation = {
          helmetAngle: Math.random() * 0.2 - 0.1,
          weaponAngle: Math.random() * 0.3 - 0.15,
          bodyTint: `hsl(${Math.random() * 20}, 70%, ${40 + Math.random() * 10}%)`,
          furShade: Math.random() * 0.2 + 0.8,
          earSize: 0.8 + Math.random() * 0.4,
          tailLength: 0.8 + Math.random() * 0.4
        };
      }
      
      update() {
        // Store previous position for movement detection
        const prevX = this.x;
        const prevY = this.y;
        
        // Find nearest target (building or unit)
        if (!this.target || this.target.health <= 0) {
          let nearestDist = Infinity;
          let nearestTarget = null;
          
          // Check buildings
          for (const building of buildings) {
            if (building.constructionProgress >= 100) {
              const dist = Math.hypot(building.x - this.x, building.y - this.y);
              if (dist < nearestDist) {
                nearestDist = dist;
                nearestTarget = building;
              }
            }
          }
          
          // Check units
          for (const unit of units) {
            const dist = Math.hypot(unit.x - this.x, unit.y - this.y);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestTarget = unit;
            }
          }
          
          this.target = nearestTarget;
        }
        
        // Move towards target
        if (this.target) {
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.hypot(dx, dy);
          
          // Update facing direction
          if (Math.abs(dx) > 1) {
            this.facingDirection = dx > 0 ? 1 : -1;
          }
          
          if (dist > this.radius + (this.target.radius || 0) + 5) {
            // Move towards target
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            this.isMoving = true;
          } else if (this.attackCooldown <= 0) {
            // Attack target
            this.attackCooldown = this.attackSpeed;
            this.attackAnimation = 1;
            this.impactEffect = 1;
            this.target.health -= this.damage;
            
            // Create attack particles
            particleSystem.createBurst(this.target.x, this.target.y, 'blood', 8);
            
            // Screen shake on attack
            triggerShake(10, 5);
            
            // Check if target is destroyed
            if (this.target.health <= 0) {
              if (this.target.radius) {
                // It's a unit
                const index = units.indexOf(this.target);
                if (index > -1) {
                  units.splice(index, 1);
                  resources.population--;
                  updateResourceDisplay();
                }
              } else {
                // It's a building
                const index = buildings.indexOf(this.target);
                if (index > -1) {
                  buildings.splice(index, 1);
                }
              }
              
              this.target = null;
            }
          }
        }
        
        // Update attack cooldown
        if (this.attackCooldown > 0) {
          this.attackCooldown--;
        }
        
        // Update animations
        if (this.isMoving) {
          this.walkCycle += 0.2;
        } else {
          this.walkCycle *= 0.9; // Slow down when not moving
        }
        
        if (this.attackAnimation > 0) {
          this.attackAnimation -= 0.1;
        }
        
        if (this.impactEffect > 0) {
          this.impactEffect -= 0.15;
        }
        
        // Bobbing animation
        this.bobOffset = Math.sin(globalTime * 0.05 + this.animationOffset) * 2;
        
        // Update blood particles
        for (let i = this.bloodParticles.length - 1; i >= 0; i--) {
          const p = this.bloodParticles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1; // Gravity
          p.life--;
          
          if (p.life <= 0) {
            this.bloodParticles.splice(i, 1);
          }
        }
        
        // Add blood particles when damaged
        if (this.health < this.maxHealth && Math.random() < 0.1) {
          this.bloodParticles.push({
            x: (Math.random() - 0.5) * this.radius,
            y: -this.radius * 0.5,
            vx: (Math.random() - 0.5) * 2,
            vy: -Math.random() * 2,
            life: 20 + Math.random() * 20
          });
        }
        
        return true;
      }
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.translate(0, this.bobOffset);
        
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(0, this.radius * 0.8, this.radius * 0.8, this.radius * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw blood particles
        ctx.fillStyle = 'rgba(180, 30, 30, 0.7)';
        this.bloodParticles.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Draw enemy based on type
        if (this.type === 'raider') {
          this.drawRaider(ctx);
        } else if (this.type === 'wolf') {
          this.drawWolf(ctx);
        }
        
        // Draw health bar
        if (this.health < this.maxHealth) {
          const healthWidth = 30;
          const healthHeight = 4;
          const healthFrac = this.health / this.maxHealth;
          
          // Health bar background with border
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(-healthWidth/2 - 1, -this.radius - 11, healthWidth + 2, healthHeight + 2);
          
          // Health bar background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(-healthWidth/2, -this.radius - 10, healthWidth, healthHeight);
          
          // Health bar fill with gradient
          const gradient = ctx.createLinearGradient(-healthWidth/2, 0, healthWidth/2, 0);
          if (healthFrac > 0.6) {
            gradient.addColorStop(0, '#10b981');
            gradient.addColorStop(1, '#34d399');
          } else if (healthFrac > 0.3) {
            gradient.addColorStop(0, '#f59e0b');
            gradient.addColorStop(1, '#fcd34d');
          } else {
            gradient.addColorStop(0, '#ef4444');
            gradient.addColorStop(1, '#f87171');
          }
          
          ctx.fillStyle = gradient;
          ctx.fillRect(
            -healthWidth/2,
            -this.radius - 10,
            healthWidth * healthFrac,
            healthHeight
          );
          
          // Health bar border
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.lineWidth = 1;
          ctx.strokeRect(-healthWidth/2, -this.radius - 10, healthWidth, healthHeight);
        }
        
        ctx.restore();
      }
      
      drawRaider(ctx) {
        // Apply facing direction
        ctx.scale(this.facingDirection, 1);
        
        // Legs with walking animation
        const legOffset = Math.sin(this.walkCycle) * 3;
        ctx.strokeStyle = '#2F4F4F';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        
        // Left leg
        ctx.beginPath();
        ctx.moveTo(-5, 5);
        ctx.lineTo(-5 + legOffset, 15);
        ctx.stroke();
        
        // Right leg
        ctx.beginPath();
        ctx.moveTo(5, 5);
        ctx.lineTo(5 - legOffset, 15);
        ctx.stroke();
        
        // Body with gradient
        const bodyGradient = ctx.createRadialGradient(0, -5, 0, 0, -5, this.radius);
        bodyGradient.addColorStop(0, this.visualVariation.bodyTint);
        bodyGradient.addColorStop(1, '#5a0000');
        
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(0, -5, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Body details
        ctx.strokeStyle = '#3a0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -5, this.radius * 0.9, 0, Math.PI * 2);
        ctx.stroke();
        
        // Arms with weapon swing animation
        const armSwing = Math.sin(this.walkCycle * 0.5) * 0.3 + this.attackAnimation * 0.5;
        
        // Left arm
        ctx.strokeStyle = '#2F4F4F';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.7, -5);
        ctx.lineTo(-this.radius * 0.9, 5);
        ctx.stroke();
        
        // Right arm holding weapon
        ctx.beginPath();
        ctx.moveTo(this.radius * 0.7, -5);
        ctx.lineTo(this.radius * 0.9 + armSwing * 5, 0);
        ctx.stroke();
        
        // Helmet with detailed design
        ctx.fillStyle = '#2F4F4F';
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.6, this.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        // Helmet details
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.6, this.radius * 0.5, 0, Math.PI * 2);
        ctx.stroke();
        
        // Helmet spike
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(0, -this.radius * 1.4);
        ctx.lineTo(-3, -this.radius * 0.9);
        ctx.lineTo(3, -this.radius * 0.9);
        ctx.closePath();
        ctx.fill();
        
        // Weapon with attack effect
        ctx.save();
        ctx.translate(this.radius * 0.9 + armSwing * 5, 0);
        ctx.rotate(armSwing * 0.5 + this.visualVariation.weaponAngle);
        
        // Weapon glow when attacking
        if (this.attackAnimation > 0) {
          ctx.shadowBlur = 10;
          ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
        }
        
        // Sword blade
        ctx.fillStyle = '#C0C0C0';
        ctx.fillRect(-2, -this.radius * 0.8, 4, this.radius * 0.8);
        
        // Sword handle
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(-2, 0, 4, 5);
        
        // Crossguard
        ctx.fillStyle = '#C0C0C0';
        ctx.fillRect(-6, -2, 12, 3);
        
        ctx.restore();
        
        // Face
        ctx.fillStyle = '#FDBCB4';
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.6, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(-3, -this.radius * 0.65, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(3, -this.radius * 0.65, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Impact effect
        if (this.impactEffect > 0) {
          ctx.fillStyle = `rgba(255, 200, 0, ${this.impactEffect * 0.5})`;
          ctx.beginPath();
          ctx.arc(this.radius * 0.9, -this.radius * 0.4, 10 * this.impactEffect, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      drawWolf(ctx) {
        // Apply facing direction
        ctx.scale(this.facingDirection, 1);
        
        // Legs with running animation
        const legCycle = this.walkCycle * 1.5;
        
        ctx.strokeStyle = '#4a4a4a';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        // Front legs
        const frontLegAngle = Math.sin(legCycle) * 0.5;
        ctx.beginPath();
        ctx.moveTo(this.radius * 0.3, -this.radius * 0.2);
        ctx.lineTo(this.radius * 0.5 + Math.sin(frontLegAngle) * 5, this.radius * 0.3);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(this.radius * 0.1, -this.radius * 0.2);
        ctx.lineTo(this.radius * 0.2 + Math.sin(frontLegAngle + Math.PI) * 5, this.radius * 0.3);
        ctx.stroke();
        
        // Back legs
        const backLegAngle = Math.sin(legCycle + Math.PI) * 0.5;
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.3, -this.radius * 0.2);
        ctx.lineTo(-this.radius * 0.5 + Math.sin(backLegAngle) * 5, this.radius * 0.3);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.1, -this.radius * 0.2);
        ctx.lineTo(-this.radius * 0.2 + Math.sin(backLegAngle + Math.PI) * 5, this.radius * 0.3);
        ctx.stroke();
        
        // Tail with wagging animation
        const tailWag = Math.sin(this.walkCycle * 2) * 0.3;
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.8, -this.radius * 0.1);
        ctx.quadraticCurveTo(
          -this.radius * 1.2, 
          -this.radius * 0.3 + tailWag * 10,
          -this.radius * 1.5 * this.visualVariation.tailLength, 
          -this.radius * 0.5 + tailWag * 15
        );
        ctx.stroke();
        
        // Body with fur texture
        const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.2);
        bodyGradient.addColorStop(0, '#808080');
        bodyGradient.addColorStop(1, `rgba(60, 60, 60, ${this.visualVariation.furShade})`);
        
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Fur texture details
        ctx.strokeStyle = 'rgba(40, 40, 40, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const x = Math.cos(angle) * this.radius * 0.8;
          const y = Math.sin(angle) * this.radius * 0.5;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * 3, y + Math.sin(angle) * 3);
          ctx.stroke();
        }
        
        // Head with detailed shape
        ctx.fillStyle = '#696969';
        ctx.beginPath();
        ctx.ellipse(this.radius * 0.8, -this.radius * 0.3, this.radius * 0.7, this.radius * 0.6, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        const earAngle = Math.sin(this.walkCycle * 3) * 0.1;
        ctx.fillStyle = '#5a5a5a';
        
        // Left ear
        ctx.save();
        ctx.translate(this.radius * 0.5, -this.radius * 0.7);
        ctx.rotate(-0.5 + earAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-5, -10 * this.visualVariation.earSize);
        ctx.lineTo(5, -8 * this.visualVariation.earSize);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Right ear
        ctx.save();
        ctx.translate(this.radius * 1.0, -this.radius * 0.6);
        ctx.rotate(0.3 - earAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-5, -8 * this.visualVariation.earSize);
        ctx.lineTo(5, -10 * this.visualVariation.earSize);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Snout
        ctx.fillStyle = '#5a5a5a';
        ctx.beginPath();
        ctx.ellipse(this.radius * 1.3, -this.radius * 0.2, this.radius * 0.4, this.radius * 0.3, 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath();
        ctx.arc(this.radius * 1.5, -this.radius * 0.2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes with glow effect
        ctx.fillStyle = '#FF0000';
        ctx.shadowBlur = 5;
        ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
        ctx.beginPath();
        ctx.arc(this.radius * 1.0, -this.radius * 0.4, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.radius * 1.0, -this.radius * 0.1, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Teeth with attack animation
        const teethBaring = this.attackAnimation * 0.5;
        ctx.fillStyle = '#FFFFFF';
        ctx.save();
        ctx.translate(this.radius * 1.3, -this.radius * 0.2);
        ctx.rotate(teethBaring);
        
        // Top teeth
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(i * 3 - 4, -2);
          ctx.lineTo(i * 3 - 3, -5);
          ctx.lineTo(i * 3 - 2, -2);
          ctx.fill();
        }
        
        // Bottom teeth
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(i * 3 - 4, 2);
          ctx.lineTo(i * 3 - 3, 5);
          ctx.lineTo(i * 3 - 2, 2);
          ctx.fill();
        }
        
        ctx.restore();
        
        // Attack effect
        if (this.impactEffect > 0) {
          ctx.fillStyle = `rgba(255, 100, 0, ${this.impactEffect * 0.4})`;
          ctx.beginPath();
          ctx.arc(this.radius * 1.3, -this.radius * 0.2, 8 * this.impactEffect, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }   
    
    // Unit class with enhanced visuals
    class Unit {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;           // "settler", "builder", "worker", "warrior", "archer", "knight"
        this.radius = type === 'knight' ? 20 : type === 'warrior' ? 18 : type === 'archer' ? 16 : 16;
        this.speed  = type === 'knight' ? 3 : type === 'warrior' ? 2.5 : type === 'archer' ? 2.2 : 2;
        this.targetX = x;
        this.targetY = y;
        this.selected = false;
        this.animationOffset = Math.random() * Math.PI * 2; // idle bob
        this.weaponAngle   = 0;  // warrior swing
        this.health        = type === 'knight' ? 150 : type === 'warrior' ? 100 : type === 'archer' ? 80 : 50;
        this.maxHealth     = Number(this.health);
        this.damage        = type === 'knight' ? 25 : type === 'warrior' ? 20 : type === 'archer' ? 15 : 5;
        this.attackCooldown = 0;
        this.attackSpeed = 60; // Frames between attacks
        this.attackRange = type === 'archer' ? 150 : 30;
        
        // Worker specific properties
        if (type === 'worker') {
          this.carryCapacity = 20;
          this.currentLoad = { wood: 0, stone: 0, food: 0 };
          this.state = 'idle'; // 'idle', 'moving_to_resource', 'gathering', 'moving_to_storage', 'depositing'
          this.targetResource = null;
          this.targetStorage = null;
          this.gatherTimer = 0;
          this.gatherSpeed = 1; // Resources gathered per frame
          
          // Add these properties to track original resource position
          this.originalResourceX = 0;
          this.originalResourceY = 0;
          this.resourceWasExhausted = false;
        }
        
        // Builder specific properties
        if (type === 'builder') {
          this.buildingMode = false;
          this.buildingTarget = null;
          this.plannedBuilding = null;
        }
      }
      
      update() {
        // Handle worker resource gathering
        if (this.type === 'worker') {
          this.updateWorker();
        }
        
        // Handle builder movement to construction site
        if (this.type === 'builder' && this.plannedBuilding) {
          const dx = this.plannedBuilding.x - this.x;
          const dy = this.plannedBuilding.y - this.y;
          const dist = Math.hypot(dx, dy);
          
          const builderSpeed = this.speed * 0.5; // Adjust this value to control builder speed (default was this.speed)
          
          if (dist > 5) {
            // Move towards construction site at reduced speed
            this.x += (dx / dist) * builderSpeed;
            this.y += (dy / dist) * builderSpeed;
            
            // Dust particles while moving
            if (Math.random() < 0.1) {
              particleSystem.createParticle(
                this.x - (dx / dist) * this.radius,
                this.y - (dy / dist) * this.radius,
                'dust'
              );
            }
          } else {
            // Reached construction site - create the building and start construction
            const cost = buildingCosts[this.plannedBuilding.type];
            
            // Double-check we still have resources
            if (resources.wood >= cost.wood && resources.stone >= cost.stone) {
              // Deduct resources
              resources.wood -= cost.wood;
              resources.stone -= cost.stone;
              updateResourceDisplay();
              
              // Create the building
              const building = new Building(this.plannedBuilding.x, this.plannedBuilding.y, this.plannedBuilding.type);
              buildings.push(building);
              
              // Create start construction particles
              particleSystem.createBurst(building.x, building.y, 'sparkle', 15);
              playSound('build');
            } else {
              // Not enough resources anymore
              showQuestNotification("Not enough resources to build!");
            }
            
            // Clear the planned building
            this.plannedBuilding = null;
          }
        }
        
        // Normal movement toward target
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const dist = Math.hypot(dx, dy);
        
        const isMoving = dist > 2; // Increased threshold to prevent jitter
        if (isMoving && this.type !== 'worker' && !(this.type === 'builder' && this.buildingTarget)) {
          this.x += (dx / dist) * this.speed;
          this.y += (dy / dist) * this.speed;
          
          // Create dust particles occasionally when moving
          if (Math.random() < 0.05) {
            particleSystem.createParticle(
              this.x - (dx / dist) * this.radius,
              this.y - (dy / dist) * this.radius,
              'dust'
            );
          }
        }
        
        if (this.type === 'builder' && this.attackCooldown <= 0) {
          // Find nearest damaged building
          let nearestBuilding = null;
          let nearestDist = Infinity;
          
          for (const building of buildings) {
            if (building.health < building.maxHealth && building.constructionProgress >= 100) {
              const dist = Math.hypot(building.x - this.x, building.y - this.y);
              if (dist < nearestDist) {
                nearestDist = dist;
                nearestBuilding = building;
              }
            }
          }
          
          if (nearestBuilding && nearestDist <= Math.max(nearestBuilding.width, nearestBuilding.height) / 2 + this.radius + 10) {
            // Repair the building
            if (this.repairBuilding(nearestBuilding)) {
              this.attackCooldown = 30; // Cooldown between repairs
            }
          }
        }
        
        // Combat for military units
        let isAttacking = false;
        if ((this.type === 'warrior' || this.type === 'archer' || this.type === 'knight') && this.attackCooldown <= 0) {
          // Find nearest enemy
          let nearestEnemy = null;
          let nearestDist = Infinity;
          
          for (const enemy of enemies) {
            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
            if (dist < nearestDist && dist <= this.attackRange + this.speed) {
              nearestDist = dist;
              nearestEnemy = enemy;
            }
          }
          
          if (nearestEnemy) {
            isAttacking = true;
            // Attack enemy
            this.attackCooldown = this.attackSpeed;
            
            if (this.type === 'archer') {
              // Ranged attack - create projectile
              projectiles.push(new Projectile(
                this.x,
                this.y - this.radius * 0.5,
                nearestEnemy.x,
                nearestEnemy.y,
                this.damage,
                5,
                this
              ));
            } else {
              // Melee attack
              nearestEnemy.health -= this.damage;
              
              // Create attack particles
              if (Math.random() < 0.5) {
                particleSystem.createBurst(nearestEnemy.x, nearestEnemy.y, 'blood', 3);
              }
              
              // Only shake screen when actually hitting
              if (Math.random() < 0.3) {
                triggerShake(5, 3);
              }
              
              if (nearestEnemy.health <= 0) {
                const index = enemies.indexOf(nearestEnemy);
                if (index > -1) {
                  enemies.splice(index, 1);
                  // Death particles
                  particleSystem.createBurst(nearestEnemy.x, nearestEnemy.y, 'blood', 15);
                  
                  // Reward resources for defeating enemy
                  resources.wood += 5;
                  resources.stone += 3;
                  resources.food += 2;
                  updateResourceDisplay();
                }
              }
            }
          }
        }
        
        // Update attack cooldown
        if (this.attackCooldown > 0) {
          this.attackCooldown--;
        }
        
        // Enhanced idle animations
        const t = globalTime * 0.08 + this.animationOffset;
        this.bobOffset = Math.sin(t) * (this.type === 'knight' ? 4 : this.type === 'warrior' ? 3 : 2);
        
        if (this.type === 'warrior' || this.type === 'knight') {
          this.weaponAngle =
            Math.sin(t * 1.5) * 0.25 +  // main slow arc
            Math.sin(t * 3.0) * 0.08;   // subtle fast vibration
        } else if (this.type === 'archer') {
          this.weaponAngle =
            Math.sin(t * 1.2) * 0.15 +  // gentle primary sway
            Math.sin(t * 2.5) * 0.05;   // small secondary bounce
        } else if (this.type === 'builder') {
          this.carryAngle =
            Math.sin(t * 1.2) * 0.35 +  // gentle primary sway
            Math.sin(t * 2.5) * 0.07;   // small secondary bounce
        }
      }
      
      updateWorker() {
        switch(this.state) {
          case 'idle':
            // Worker is idle, waiting for commands
            break;
            
          case 'moving_to_resource':
            // Move to the assigned resource
            const dx = this.targetResource.x - this.x;
            const dy = this.targetResource.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > this.radius + this.targetResource.radius + 5) {
              // Move towards resource
              this.x += (dx / dist) * this.speed;
              this.y += (dy / dist) * this.speed;
              
              // Dust particles while moving
              if (Math.random() < 0.1) {
                particleSystem.createParticle(
                  this.x - (dx / dist) * this.radius,
                  this.y - (dy / dist) * this.radius,
                  'dust'
                );
              }
            } else {
              // Reached resource, start gathering
              this.state = 'gathering';
              this.gatherTimer = 0;
              
              // Store the original position of the resource
              this.originalResourceX = this.targetResource.x;
              this.originalResourceY = this.targetResource.y;
              this.resourceWasExhausted = false;
              
              // Add worker to resource's assigned workers list
              if (!this.targetResource.assignedWorkers.includes(this)) {
                this.targetResource.assignedWorkers.push(this);
              }
            }
            break;
            
          case 'gathering':
            // Gather resources from the node
            this.gatherTimer++;
            
            // Gather resources at a rate of 1 per 10 frames
            if (this.gatherTimer % 10 === 0) {
              const gathered = this.targetResource.gather(this.gatherSpeed);
              
              if (this.targetResource.type === 'tree') {
                this.currentLoad.wood += gathered;
              } else if (this.targetResource.type === 'rock') {
                this.currentLoad.stone += gathered;
              } else if (this.targetResource.type === 'bush') {
                this.currentLoad.food += gathered;
              }
              
              // Create gather particles
              if (Math.random() < 0.1) {
                particleSystem.createParticle(
                  this.x + (Math.random() - 0.5) * 10,
                  this.y + (Math.random() - 0.5) * 10,
                  'dust'
                );
              }
              
              // Check if resource was exhausted during this gathering
              if (this.targetResource.amount <= 0) {
                this.resourceWasExhausted = true;
              }
            }
            
            // Check if worker is full or resource is depleted
            const totalLoad = this.currentLoad.wood + this.currentLoad.stone + this.currentLoad.food;
            if (totalLoad >= this.carryCapacity || this.targetResource.amount <= 0) {
              // Remove worker from resource's assigned workers list
              const index = this.targetResource.assignedWorkers.indexOf(this);
              if (index > -1) {
                this.targetResource.assignedWorkers.splice(index, 1);
              }
              
              // Find nearest storage (Town Hall)
              let nearestStorage = null;
              let nearestDist = Infinity;
              
              for (const building of buildings) {
                if (building.type === 'townhall' && building.constructionProgress >= 100) {
                  const dist = Math.hypot(building.x - this.x, building.y - this.y);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestStorage = building;
                  }
                }
              }
              
              if (nearestStorage) {
                this.targetStorage = nearestStorage;
                this.targetX = nearestStorage.x;
                this.targetY = nearestStorage.y;
                this.state = 'moving_to_storage';
              } else {
                // No storage found, go idle
                this.state = 'idle';
                this.targetResource = null;
              }
            }
            break;
            
          case 'moving_to_storage':
            // Move to the storage building
            const sdx = this.targetStorage.x - this.x;
            const sdy = this.targetStorage.y - this.y;
            const sdist = Math.hypot(sdx, sdy);
            
            if (sdist > this.radius + Math.max(this.targetStorage.width, this.targetStorage.height) / 2 + 5) {
              // Move towards storage
              this.x += (sdx / sdist) * this.speed;
              this.y += (sdy / sdist) * this.speed;
              
              // Dust particles while moving
              if (Math.random() < 0.1) {
                particleSystem.createParticle(
                  this.x - (sdx / sdist) * this.radius,
                  this.y - (sdy / sdist) * this.radius,
                  'dust'
                );
              }
            } else {
              // Reached storage, deposit resources
              this.state = 'depositing';
            }
            break;
            
          case 'depositing':
            // Deposit resources at storage
            resources.wood += this.currentLoad.wood;
            resources.stone += this.currentLoad.stone;
            resources.food += this.currentLoad.food;
            
            // Reset load
            this.currentLoad = { wood: 0, stone: 0, food: 0 };
            
            // Update resource display
            updateResourceDisplay();
            
            // Create deposit particles
            particleSystem.createBurst(this.x, this.y, 'sparkle', 5);
            playSound('collect');
            
            // Check if the resource was exhausted or has moved
            if (this.resourceWasExhausted || 
                this.targetResource.x !== this.originalResourceX || 
                this.targetResource.y !== this.originalResourceY) {
              // Resource was exhausted or moved, go idle
              this.state = 'idle';
              this.targetResource = null;
            } else if (this.targetResource.amount > 0) {
              // Resource still exists at original location, go back to gathering
              this.targetX = this.targetResource.x;
              this.targetY = this.targetResource.y;
              this.state = 'moving_to_resource';
            } else {
              // Resource is depleted, go idle
              this.state = 'idle';
              this.targetResource = null;
            }
            break;
        }
      }     
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Soft, gradient shadow
        ctx.save();
        ctx.filter = 'blur(4px)';
        const shadowGradient = ctx.createRadialGradient(
          0, this.radius * 0.6, this.radius * 0.2,
          0, this.radius * 0.6, this.radius * 0.8
        );
        shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
        shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = shadowGradient;
        ctx.beginPath();
        ctx.ellipse(
          0,
          this.radius * 0.6,
          this.radius * 0.8,
          this.radius * 0.3,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();
        ctx.filter = 'none';
        ctx.restore();
        
        // Bobbing
        ctx.translate(0, this.bobOffset);
        
        // Draw unit based on type
        if (this.type === 'warrior') {
          this.drawWarrior(ctx);
        } else if (this.type === 'archer') {
          this.drawArcher(ctx);
        } else if (this.type === 'knight') {
          this.drawKnight(ctx);
        } else if (this.type === 'builder') {
          this.drawBuilder(ctx);
        } else if (this.type === 'worker') {
          this.drawWorker(ctx);
        } else {
          this.drawSettler(ctx);
        }
        
        // Selection ring & path
        if (this.selected) {
          // Smooth pulsing opacity instead of changing line width
          const pulseAlpha = 0.4 + 0.4 * Math.sin(globalTime * 0.05); // Smooth fade between 0.0 and 0.8
          ctx.strokeStyle = `rgba(245, 158, 11, ${pulseAlpha})`;
          ctx.lineWidth = 2; // Fixed line width for consistency
          
          // Draw selection ring
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, 2 * Math.PI);
          ctx.stroke();
          
          // Add a subtle glow effect
          ctx.shadowBlur = 10;
          ctx.shadowColor = 'rgba(245, 158, 11, 0.5)';
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.shadowBlur = 0; // Reset shadow
          
          // Path to target
          if (this.x !== this.targetX || this.y !== this.targetY) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(this.targetX - this.x, this.targetY - this.y);
            ctx.strokeStyle = `rgba(245, 158, 11, ${pulseAlpha * 0.5})`; // Faded path
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          
          // Attack range indicator for military units
          if (this.type === 'warrior' || this.type === 'archer' || this.type === 'knight') {
            ctx.beginPath();
            ctx.arc(0, 0, this.attackRange, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(239, 68, 68, ${pulseAlpha * 0.3})`; // Faded range indicator
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
        
        // Add this to the Unit class draw method after the selection ring drawing
        if (this.selected && this.type === 'builder' && this.buildingTarget) {
          // Draw line to building target
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(this.buildingTarget.x - this.x, this.buildingTarget.y - this.y);
          ctx.strokeStyle = 'rgba(245, 158, 11, 0.7)';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 3]);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Draw building target indicator
          ctx.fillStyle = 'rgba(245, 158, 11, 0.5)';
          ctx.beginPath();
          ctx.arc(this.buildingTarget.x - this.x, this.buildingTarget.y - this.y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(245, 158, 11, 0.8)';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // Health bar (if injured or selected)
        if (this.health < this.maxHealth || this.selected) {
          const healthWidth = 30;
          const healthHeight = 4;
          const healthFrac = this.health / this.maxHealth;
          
          // Background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(-healthWidth/2, -this.radius - 10, healthWidth, healthHeight);
          
          // Foreground
          ctx.fillStyle = healthFrac > 0.6
            ? '#10b981'
            : healthFrac > 0.3
              ? '#f59e0b'
              : '#ef4444';
          ctx.fillRect(
            -healthWidth/2,
            -this.radius - 10,
            healthWidth * healthFrac,
            healthHeight
          );
        }
        
        // Worker load indicator
        if (this.type === 'worker' && this.selected) {
          const totalLoad = this.currentLoad.wood + this.currentLoad.stone + this.currentLoad.food;
          if (totalLoad > 0) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-25, -this.radius - 25, 50, 20);
            
            ctx.fillStyle = '#fcd34d';
            ctx.font = '10px MedievalSharp, cursive';
            ctx.textAlign = 'center';
            ctx.fillText(
              `W:${this.currentLoad.wood} S:${this.currentLoad.stone} F:${this.currentLoad.food}`,
              0,
              -this.radius - 10
            );
          }
        }
        
        ctx.restore();
      }
      
      drawWarrior(ctx) {
        // Only create selection effects when actually selected
        if (this.selected) {
          // Only create selection particles occasionally
          if (Math.random() < 0.02) { // Very low chance
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * this.radius;
            particleSystem.createParticle(
              this.x + Math.cos(angle) * dist,
              this.y + Math.sin(angle) * dist,
              'sparkle'
            );
          }
        }
        
        // Torso with subtle radial shading
        const torsoGrad = ctx.createRadialGradient(
          0, 0, this.radius * 0.2,     // inner bright spot
          0, 0, this.radius * 0.7      // outer edge
        );
        torsoGrad.addColorStop(0, '#3b82f6');   // core color
        torsoGrad.addColorStop(1, '#1e40af');   // rim darkening
        ctx.fillStyle = torsoGrad;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#1e40af';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Armor details
        ctx.beginPath();
        ctx.arc(0, -this.radius*0.2, this.radius*0.5, Math.PI*0.2, Math.PI*0.8);
        ctx.strokeStyle='#1e3a8a';
        ctx.lineWidth=3;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, -this.radius*0.2, this.radius*0.45, Math.PI*0.2, Math.PI*0.8);
        ctx.strokeStyle='#63b3ed';
        ctx.lineWidth=2;
        ctx.stroke();
        
        // Helmet
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.6, this.radius * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = '#1e40af';
        ctx.fill();
        ctx.strokeStyle = '#1e3a8a';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Weapon (sword)
        ctx.save();
        ctx.rotate(this.weaponAngle);
        ctx.fillStyle = '#a1a1aa';
        ctx.fillRect(this.radius * 0.7, -this.radius * 0.1, this.radius * 0.8, this.radius * 0.2);
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(this.radius * 1.5 - 5, -this.radius * 0.05, 5, this.radius * 0.1);
        ctx.restore();
        
        // Shield
        ctx.beginPath();
        ctx.arc(-this.radius * 0.8, 0, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#1e40af';
        ctx.fill();
        ctx.strokeStyle = '#1e3a8a';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Shield cross
        ctx.strokeStyle = '#d1d5db';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.8, -this.radius * 0.4);
        ctx.lineTo(-this.radius * 0.8, this.radius * 0.4);
        ctx.moveTo(-this.radius * 1.0, 0);
        ctx.lineTo(-this.radius * 0.6, 0);
        ctx.stroke();
      }      
      
      drawArcher(ctx) {
        // Torso
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, 2 * Math.PI);
        ctx.fillStyle = '#10b981';
        ctx.fill();
        ctx.strokeStyle = '#047857';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Head
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.9, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#FBBF24';
        ctx.fill();
        ctx.strokeStyle = '#D97706';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Bow
        ctx.save();
        ctx.rotate(this.weaponAngle);
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.9, -Math.PI * 0.3, Math.PI * 0.3);
        ctx.stroke();
        
        // Bowstring
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(
          Math.cos(-Math.PI * 0.3) * this.radius * 0.9,
          Math.sin(-Math.PI * 0.3) * this.radius * 0.9
        );
        ctx.lineTo(
          Math.cos(Math.PI * 0.3) * this.radius * 0.9,
          Math.sin(Math.PI * 0.3) * this.radius * 0.9
        );
        ctx.stroke();
        
        // Arrow
        ctx.strokeStyle = '#696969';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.radius * 1.2, 0);
        ctx.stroke();
        ctx.restore();
        
        // Quiver
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(-this.radius * 0.8, -this.radius * 0.2, 5, this.radius * 0.8);
        
        // Arrows in quiver
        ctx.strokeStyle = '#696969';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(-this.radius * 0.8, -this.radius * 0.2 + i * 5);
          ctx.lineTo(-this.radius * 0.8 - 10, -this.radius * 0.2 + i * 5 - 5);
          ctx.stroke();
        }
      }
      
      drawKnight(ctx) {
        // Torso with armor
        const torsoGrad = ctx.createRadialGradient(
          0, 0, this.radius * 0.2,
          0, 0, this.radius * 0.8
        );
        torsoGrad.addColorStop(0, '#d1d5db');   // core color
        torsoGrad.addColorStop(1, '#9ca3af');   // rim darkening
        ctx.fillStyle = torsoGrad;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.8, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#6b7280';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Armor details
        ctx.beginPath();
        ctx.arc(0, -this.radius*0.2, this.radius*0.6, Math.PI*0.2, Math.PI*0.8);
        ctx.strokeStyle='#4b5563';
        ctx.lineWidth=4;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, -this.radius*0.2, this.radius*0.55, Math.PI*0.2, Math.PI*0.8);
        ctx.strokeStyle='#d1d5db';
        ctx.lineWidth=2;
        ctx.stroke();
        
        // Helmet
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.7, this.radius * 0.7, 0, Math.PI * 2);
        ctx.fillStyle = '#9ca3af';
        ctx.fill();
        ctx.strokeStyle = '#6b7280';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Helmet plume
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.moveTo(0, -this.radius * 1.3);
        ctx.lineTo(-this.radius * 0.3, -this.radius * 0.8);
        ctx.lineTo(this.radius * 0.3, -this.radius * 0.8);
        ctx.closePath();
        ctx.fill();
        
        // Weapon (sword)
        ctx.save();
        ctx.rotate(this.weaponAngle);
        ctx.fillStyle = '#a1a1aa';
        ctx.fillRect(this.radius * 0.8, -this.radius * 0.15, this.radius * 1.0, this.radius * 0.3);
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(this.radius * 1.8 - 7, -this.radius * 0.07, 7, this.radius * 0.14);
        ctx.restore();
        
        // Shield
        ctx.beginPath();
        ctx.arc(-this.radius * 0.9, 0, this.radius * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = '#dc2626';
        ctx.fill();
        ctx.strokeStyle = '#991b1b';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Shield emblem
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.9, -this.radius * 0.3);
        ctx.lineTo(-this.radius * 0.6, 0);
        ctx.lineTo(-this.radius * 0.9, this.radius * 0.3);
        ctx.lineTo(-this.radius * 1.2, 0);
        ctx.closePath();
        ctx.fill();
      }
      
      drawBuilder(ctx) {
        // Body (Tunic)
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, 2 * Math.PI);
        ctx.fillStyle = '#8B4513';    // brown
        ctx.fill();
        ctx.strokeStyle = '#5D4037';  // darker outline
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Head (Circle)
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.9, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#FBBF24';    // warm yellow (skin)
        ctx.fill();
        ctx.strokeStyle = '#D97706';  // brown outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Hammer
        ctx.save();
        ctx.translate(this.radius * 0.1, -this.radius * 0.6);
        ctx.rotate(this.carryAngle);
        
        // Handle (wood)
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(-2, -3, 4, this.radius * 1.2);
        
        // Head (steel)
        ctx.fillStyle = '#E5E7EB';
        ctx.fillRect(-8, -5, 16, 8);
        ctx.restore();
      }
      
      drawWorker(ctx) {
        // Body (Tunic)
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, 2 * Math.PI);
        ctx.fillStyle = '#3b82f6';    // blue
        ctx.fill();
        ctx.strokeStyle = '#1d4ed8';  // darker outline
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Head (Circle)
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.9, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#FBBF24';    // warm yellow (skin)
        ctx.fill();
        ctx.strokeStyle = '#D97706';  // brown outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Pickaxe
        ctx.save();
        ctx.translate(this.radius * 0.1, -this.radius * 0.6);
        ctx.rotate(this.carryAngle);
        
        // Handle (wood)
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(-2, -3, 4, this.radius * 1.2);
        
        // Head (steel)
        ctx.fillStyle = '#E5E7EB';
        ctx.beginPath();
        ctx.moveTo(-8, -5);
        ctx.lineTo(8, -5);
        ctx.lineTo(4, 5);
        ctx.lineTo(-4, 5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      
      drawSettler(ctx) {
        // Body (Tunic)
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, 2 * Math.PI);
        ctx.fillStyle = '#34D399';    // soft green
        ctx.fill();
        ctx.strokeStyle = '#059669';  // darker outline
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Head (Circle)
        ctx.beginPath();
        ctx.arc(0, -this.radius * 0.9, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#FBBF24';    // warm yellow (skin)
        ctx.fill();
        ctx.strokeStyle = '#D97706';  // brown outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Axe
        ctx.save();
        ctx.translate(this.radius * 0.1, -this.radius * 0.6);
        ctx.rotate(this.carryAngle);
        
        // Handle (wood)
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(-2, -3, 4, this.radius * 1.2);
        
        // Blade (steel)
        ctx.beginPath();
        ctx.moveTo(2, 0);
        ctx.lineTo(10, -6);
        ctx.lineTo(10, 6);
        ctx.closePath();
        ctx.fillStyle = '#E5E7EB';
        ctx.fill();
        ctx.restore();
      }
    }
    
    // Building class with enhanced visuals
    class Building {
      constructor(x, y, type = 'townhall') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.width = this.getBuildingDimensions().width;
        this.height = this.getBuildingDimensions().height;
        this.constructionProgress = 0;
        this.completionTime = this.getBuildingDimensions().completionTime;
        this.lightFlicker = 0;
        this.smokeParticles = [];
        this.hasChimney = type === 'townhall' || type === 'house' || type === 'lumbermill';
        this.windowColors = ['#8a6d3b', '#6b4226', '#d4a76a', '#7a6a5f'];
        this.productionTimer = 0;
        this.productionInterval = this.getProductionInterval();
        this.health = this.getBuildingHealth();
        this.maxHealth = this.health;
        this.lastDamageTime = 0;
        this.animationOffset = Math.random() * Math.PI * 2;
        this.bannerWave = 0;
        this.hasBanner = type === 'townhall' || type === 'barracks' || type === 'castle';
        this.torchParticles = [];
        this.torchOn = false;
        this.justCompleted = false;
        this.wasDamaged = false;
      }
      
      updateTorchState() {
        const isNight = dayNightCycle > 1800 && dayNightCycle < 3240; // 50% to 90% of 3600
        // All completed buildings have torches at night
        if (this.constructionProgress >= 100) {
          this.torchOn = isNight;
        }
      }
      
      getBuildingDimensions() {
        switch(this.type) {
          case 'townhall':
            return { width: 90, height: 90, completionTime: 240 };
          case 'house':
            return { width: 70, height: 70, completionTime: 180 };
          case 'farm':
            return { width: 80, height: 80, completionTime: 200 };
          case 'quarry':
            return { width: 85, height: 85, completionTime: 220 };
          case 'lumbermill':
            return { width: 90, height: 70, completionTime: 210 };
          case 'barracks':
            return { width: 100, height: 80, completionTime: 230 };
          case 'tower':
            return { width: 60, height: 100, completionTime: 200 };
          case 'castle':
            return { width: 150, height: 150, completionTime: 500 };
          default:
            return { width: 70, height: 70, completionTime: 180 };
        }
      }
      
      getProductionInterval() {
        switch(this.type) {
          case 'farm':
            return 300;
          case 'quarry':
            return 400;
          case 'lumbermill':
            return 350;
          case 'house':
            return 0;
          case 'barracks':
            return 0;
          case 'tower':
            return 60;
          default:
            return 0;
        }
      }
      
      getBuildingHealth() {
        switch(this.type) {
          case 'townhall':
            return 300;
          case 'house':
            return 150;
          case 'farm':
            return 200;
          case 'quarry':
            return 250;
          case 'lumbermill':
            return 200;
          case 'barracks':
            return 250;
          case 'tower':
            return 300;
          case 'castle':
            return 500;
          default:
            return 150;
        }
      }
      
      update() {
        const isNight = dayNightCycle > 1800 && dayNightCycle < 3240; // 50% to 90% of 3600
        if ((this.type === 'townhall' || this.type === 'barracks' || this.type === 'castle') && this.constructionProgress >= 100) {
          this.torchOn = isNight;
        }
        
        this.lightFlicker = Math.sin(globalTime * 0.1) * 0.2 + 1;
        this.bannerWave = Math.sin(globalTime * 0.05 + this.animationOffset) * 0.1;
        this.updateTorchState();
        
        if (this.constructionProgress < 100) {
          this.constructionProgress += 100 / this.completionTime;
          
          // Clamp to 100 to prevent exceeding 100%
          if (this.constructionProgress > 100) {
            this.constructionProgress = 100;
          }
          
          if (Math.random() < 0.05 && this.constructionProgress < 95) {
            particleSystem.createBurst(this.x, this.y - this.height/2, 'dust', 3);
          }
          
          if (this.constructionProgress >= 100 && !this.justCompleted) {
            this.justCompleted = true;
            this.onConstructionComplete();
            
            // Update UI if this building is selected
            if (selectedBuilding === this) {
              updateBuildingInfo();
            }
          }
        } else {
          if (this.productionInterval > 0) {
            this.productionTimer++;
            
            if (this.productionTimer >= this.productionInterval) {
              this.productionTimer = 0;
              this.produceResources();
            }
          }
          
          if (this.type === 'tower') {
            this.productionTimer++;
            
            if (this.productionTimer >= this.productionInterval) {
              this.productionTimer = 0;
              
              let nearestEnemy = null;
              let nearestDist = Infinity;
              
              for (const enemy of enemies) {
                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (dist < nearestDist && dist <= 250) {
                  nearestDist = dist;
                  nearestEnemy = enemy;
                }
              }
              
              if (nearestEnemy) {
                projectiles.push(new Projectile(
                  this.x,
                  this.y - this.height * 0.4,
                  nearestEnemy.x,
                  nearestEnemy.y,
                  30,
                  6,
                  this
                ));
              }
            }
          }
        }
        
        if (this.hasChimney && this.constructionProgress >= 100) {
          if (Math.random() < 0.08) {
            this.smokeParticles.push({
              x: this.x + (this.type === 'townhall' ? -25 : this.type === 'lumbermill' ? 30 : 20),
              y: this.y - this.height * 0.55,
              size: 2 + Math.random() * 3,
              lifetime: 80 + Math.random() * 60,
              xVel: (Math.random() - 0.5) * 0.2,
              yVel: -0.8 - Math.random() * 0.4
            });
          }
          
          for (let i = this.smokeParticles.length - 1; i >= 0; i--) {
            const p = this.smokeParticles[i];
            p.y += p.yVel;
            p.x += p.xVel;
            p.size += 0.08;
            p.lifetime--;
            
            if (p.lifetime <= 0) {
              this.smokeParticles.splice(i, 1);
            }
          }
        }
        
        // Update torch particles for all buildings
        if (this.constructionProgress >= 100 && this.torchOn && Math.random() < 0.1) {
          let particleX;
          if (this.type === 'townhall') {
            particleX = 35;
          } else if (this.type === 'house') {
            particleX = 25;
          } else if (this.type === 'farm') {
            particleX = 30;
          } else if (this.type === 'quarry') {
            particleX = 30;
          } else if (this.type === 'lumbermill') {
            particleX = 35;
          } else if (this.type === 'barracks') {
            particleX = 30;
          } else if (this.type === 'tower') {
            particleX = 0;
          } else {
            particleX = 30; // Default for other building types
          }
          
          this.torchParticles.push({
            x: this.x + particleX,
            y: this.y - this.height * 0.7,
            size: 1 + Math.random() * 2,
            lifetime: 20 + Math.random() * 20,
            xVel: (Math.random() - 0.5) * 0.3,
            yVel: -0.5 - Math.random() * 0.3
          });
        }
        
        for (let i = this.torchParticles.length - 1; i >= 0; i--) {
          const p = this.torchParticles[i];
          p.y += p.yVel;
          p.x += p.xVel;
          p.lifetime--;
          
          if (p.lifetime <= 0) {
            this.torchParticles.splice(i, 1);
          }
        }
      }
      
      takeDamage(amount) {
        this.health -= amount;
        this.wasDamaged = true;
        this.lastDamageTime = globalTime;
        
        // Create damage particles
        particleSystem.createBurst(this.x, this.y, 'blood', 5);
        
        // Screen shake on damage
        triggerShake(10, 5);
        playSound('damage');
      }
      
      produceResources() {
        switch(this.type) {
          case 'farm':
            resources.food += 10;
            break;
          case 'quarry':
            resources.stone += 8;
            break;
          case 'lumbermill':
            resources.wood += 12;
            break;
        }
        
        updateResourceDisplay();
        
        particleSystem.createBurst(this.x, this.y, 'sparkle', 5);
      }
      
      onConstructionComplete() {
        if (this.type === 'house') {
          resources.populationCap += 3;
          updateResourceDisplay();
        }
        
        if (this.type === 'townhall') {
          territories.push({
            x: this.x,
            y: this.y,
            radius: TERRITORY_RADIUS
          });
          
          // Set global flag that Town Hall is built
          townHallBuilt = true;
        } else {
          // Expand territory for other buildings
          this.expandTerritory();
        }
        
        if (this.type === 'townhall' && !questState.mainQuestComplete) {
          questState.mainQuestComplete = true;
          showQuestNotification("Town Hall built! Now build up your settlement and defend against enemies.");
          playSound('quest');
          
          questState.sideQuests.push("Build 3 Houses to increase population capacity");
          questState.sideQuests.push("Build a Farm to produce food");
          questState.sideQuests.push("Train 3 Warriors to defend your settlement");
        }
        
        if (this.type === 'castle') {
          showQuestNotification("Castle built! Prepare for the final attack!");
          playSound('quest');
          enemyWaveNumber = 10;
          spawnEnemyWave();
        }
        
        particleSystem.createBurst(this.x, this.y, 'sparkle', 30);
        triggerShake(25, 10);
      }
      
      expandTerritory() {
        const EXPANSION_DISTANCE = 150; // How far the territory expands
        let expanded = false;
        
        // Check all existing territories
        for (const territory of territories) {
          const dist = Math.hypot(territory.x - this.x, territory.y - this.y);
          
          // If building is within expansion distance of territory
          if (dist <= territory.radius + EXPANSION_DISTANCE) {
            // Calculate direction from territory center to building
            const dx = this.x - territory.x;
            const dy = this.y - territory.y;
            const angle = Math.atan2(dy, dx);
            
            // Calculate how much we need to expand to include this building
            const buildingDist = Math.max(this.width, this.height) / 2;
            const requiredRadius = dist + buildingDist + 50; // 50 buffer
            
            // Only expand if needed
            if (requiredRadius > territory.radius) {
              // Calculate expansion amount
              const expansionAmount = requiredRadius - territory.radius;
              
              // Create a directional expansion vector
              const expansionVector = {
                x: Math.cos(angle) * expansionAmount,
                y: Math.sin(angle) * expansionAmount
              };
              
              // Move the territory center slightly in the direction of expansion (only 10% of the way)
              const centerShift = 0.1; // Adjust this value (0-1) to control how much the center moves
              territory.x += expansionVector.x * centerShift;
              territory.y += expansionVector.y * centerShift;
              
              // Set the new radius to cover the building
              territory.radius = requiredRadius;
              
              // Add directional expansion particles
              for (let i = 0; i < 15; i++) {
                // Create particles in a fan pattern in the expansion direction
                const spreadAngle = angle + (Math.random() - 0.5) * 0.4;
                const distance = territory.radius * (0.7 + Math.random() * 0.3);
                particleSystem.createParticle(
                  territory.x + Math.cos(spreadAngle) * distance,
                  territory.y + Math.sin(spreadAngle) * distance,
                  'sparkle'
                );
              }
              
              expanded = true;
              break; // Only expand the first territory we find
            }
          }
        }
        
        // If no territory was expanded and we have a Town Hall, create a new territory
        if (!expanded && townHallBuilt) {
          // Find the Town Hall
          for (const building of buildings) {
            if (building.type === 'townhall' && building.constructionProgress >= 100) {
              const dist = Math.hypot(building.x - this.x, building.y - this.y);
              
              // If building is within expansion distance of Town Hall
              if (dist <= TERRITORY_RADIUS + EXPANSION_DISTANCE) {
                // Calculate direction from Town Hall to building
                const dx = this.x - building.x;
                const dy = this.y - building.y;
                const angle = Math.atan2(dy, dx);
                
                // Calculate how much we need to expand to include this building
                const buildingDist = Math.max(this.width, this.height) / 2;
                const requiredRadius = dist + buildingDist + 50; // 50 buffer
                
                // Only expand if needed
                if (requiredRadius > TERRITORY_RADIUS) {
                  // Calculate expansion amount
                  const expansionAmount = requiredRadius - TERRITORY_RADIUS;
                  
                  // Create a directional expansion vector
                  const expansionVector = {
                    x: Math.cos(angle) * expansionAmount,
                    y: Math.sin(angle) * expansionAmount
                  };
                  
                  // Find the main territory (centered on Town Hall)
                  for (const territory of territories) {
                    if (Math.hypot(territory.x - building.x, territory.y - building.y) < 10) {
                      // Move the territory center slightly in the direction of expansion
                      const centerShift = 0.1; // Adjust this value (0-1) to control how much the center moves
                      territory.x += expansionVector.x * centerShift;
                      territory.y += expansionVector.y * centerShift;
                      
                      // Set the new radius to cover the building
                      territory.radius = requiredRadius;
                      
                      // Add directional expansion particles
                      for (let i = 0; i < 15; i++) {
                        // Create particles in a fan pattern in the expansion direction
                        const spreadAngle = angle + (Math.random() - 0.5) * 0.4;
                        const distance = territory.radius * (0.7 + Math.random() * 0.3);
                        particleSystem.createParticle(
                          territory.x + Math.cos(spreadAngle) * distance,
                          territory.y + Math.sin(spreadAngle) * distance,
                          'sparkle'
                        );
                      }
                      break;
                    }
                  }
                }
              }
              break;
            }
          }
        }
      }
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // For planned buildings, draw as a ghost/transparent preview
        if (this.constructionProgress === -1) {
          ctx.globalAlpha = 0.4;
        }
        
        const shadowWidth = this.width * (this.constructionProgress < 100 ? 0.8 : 1.2);
        const shadowHeight = this.height * (this.constructionProgress < 100 ? 0.2 : 0.3);
        ctx.beginPath();
        ctx.ellipse(0, this.height * 0.3, shadowWidth * 0.5, shadowHeight * 0.5, 0, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(0, 0, 0, ${this.constructionProgress < 100 ? 0.3 : 0.4})`;
        ctx.fill();
        
        const heightScale = this.constructionProgress === -1 ? 0.1 : (this.constructionProgress / 100);
        const currentHeight = this.height * heightScale;
        
        this.drawFoundation(ctx, currentHeight);
        
        if (this.constructionProgress > 30 || this.constructionProgress === -1) {
          this.drawMainStructure(ctx, currentHeight);
        }
        
        if (this.constructionProgress > 60 || this.constructionProgress === -1) {
          this.drawRoof(ctx, currentHeight);
        }
        
        if (this.constructionProgress > 80 || this.constructionProgress === -1) {
          this.drawDetails(ctx, currentHeight);
        }
        
        if (this.constructionProgress >= 0 && this.constructionProgress < 100) {
          this.drawConstructionProgress(ctx, currentHeight);
        } else if (this.constructionProgress === -1) {
          // Draw planned indicator
          ctx.fillStyle = 'rgba(245, 158, 11, 0.8)';
          ctx.font = '12px MedievalSharp, cursive';
          ctx.textAlign = 'center';
          ctx.fillText('PLANNED', 0, -this.height/2 - 15);
        }
        
        this.drawSmoke(ctx);
        this.drawTorchParticles(ctx);
        
        // Draw torches for all building types
        if (this.torchOn && this.constructionProgress >= 100) {
          // Determine torch positions based on building type
          let torchPositions = [];
          
          if (this.type === 'townhall') {
            torchPositions = [
              { x: -this.width * 0.35, y: -this.height * 0.6 }
            ];
          } else if (this.type === 'house') {
            torchPositions = [
              { x: -this.width * 0.25, y: -this.height * 0.5 },
              { x: this.width * 0.25, y: -this.height * 0.5 }
            ];
          } else if (this.type === 'farm') {
            torchPositions = [
              { x: -this.width * 0.3, y: -this.height * 0.4 },
              { x: this.width * 0.3, y: -this.height * 0.4 }
            ];
          } else if (this.type === 'quarry') {
            torchPositions = [
              { x: -this.width * 0.3, y: -this.height * 0.4 },
              { x: this.width * 0.3, y: -this.height * 0.4 }
            ];
          } else if (this.type === 'lumbermill') {
            torchPositions = [
              { x: -this.width * 0.35, y: -this.height * 0.5 },
              { x: this.width * 0.35, y: -this.height * 0.5 }
            ];
          } else if (this.type === 'barracks') {
            torchPositions = [
              { x: -this.width * 0.3, y: -this.height * 0.6 },
              { x: this.width * 0.3, y: -this.height * 0.6 }
            ];
          } else if (this.type === 'tower') {
            torchPositions = [
              { x: 0, y: -this.height * 0.8 }
            ];
          } else {
            // Default for any other building types
            torchPositions = [
              { x: -this.width * 0.3, y: -this.height * 0.5 },
              { x: this.width * 0.3, y: -this.height * 0.5 }
            ];
          }
          
          // Draw each torch with lighting effect
          torchPositions.forEach(pos => {
            // Torch flame with flickering effect
            const flameSize = 4 + Math.sin(globalTime * 0.1 + pos.x) * 1;
            const flameOffset = Math.sin(globalTime * 0.15 + pos.x) * 2;
            
            // Create a radial gradient for the torch light illumination
            const lightRadius = 80 + Math.sin(globalTime * 0.08 + pos.x) * 20;
            const lightGradient = ctx.createRadialGradient(
              pos.x + flameOffset, pos.y, 0,
              pos.x + flameOffset, pos.y, lightRadius
            );
            lightGradient.addColorStop(0, 'rgba(255, 200, 50, 0.3)');
            lightGradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.1)');
            lightGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            
            // Draw the light illumination
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = lightGradient;
            ctx.beginPath();
            ctx.arc(pos.x + flameOffset, pos.y, lightRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Torch flame glow
            const flameGradient = ctx.createRadialGradient(
              pos.x + flameOffset, pos.y, 0,
              pos.x + flameOffset, pos.y, flameSize * 3
            );
            flameGradient.addColorStop(0, 'rgba(255, 200, 50, 0.8)');
            flameGradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.4)');
            flameGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            
            ctx.fillStyle = flameGradient;
            ctx.beginPath();
            ctx.arc(pos.x + flameOffset, pos.y, flameSize * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Flame core
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(pos.x + flameOffset, pos.y, flameSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner flame
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.arc(pos.x + flameOffset, pos.y, flameSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // Torch stick
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(pos.x - 1, pos.y, 2, 10);
            
            // Add torch particles
            if (Math.random() < 0.3) {
              this.torchParticles.push({
                x: pos.x + flameOffset,
                y: pos.y,
                size: 1 + Math.random() * 2,
                lifetime: 15 + Math.random() * 15,
                xVel: (Math.random() - 0.5) * 0.5,
                yVel: -0.3 - Math.random() * 0.2
              });
            }
          });
        }
        
        // Health bar (if injured or selected)
        if (this.health < this.maxHealth || this.selected) {
          const healthWidth = 30;
          const healthHeight = 4;
          const healthFrac = this.health / this.maxHealth;
          const healthPercent = Math.round(healthFrac * 100);
          
          // Background with border
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(-healthWidth/2 - 1, -this.radius - 12, healthWidth + 2, healthHeight + 2);
          
          // Background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(-healthWidth/2, -this.radius - 11, healthWidth, healthHeight);
          
          // Health bar fill with gradient
          const gradient = ctx.createLinearGradient(-healthWidth/2, 0, healthWidth/2, 0);
          if (healthFrac > 0.6) {
            gradient.addColorStop(0, '#10b981');
            gradient.addColorStop(1, '#34d399');
          } else if (healthFrac > 0.3) {
            gradient.addColorStop(0, '#f59e0b');
            gradient.addColorStop(1, '#fcd34d');
          } else {
            gradient.addColorStop(0, '#ef4444');
            gradient.addColorStop(1, '#f87171');
          }
          
          ctx.fillStyle = gradient;
          ctx.fillRect(
            -healthWidth/2,
            -this.radius - 11,
            healthWidth * healthFrac,
            healthHeight
          );
          
          // Health bar border
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.lineWidth = 1;
          ctx.strokeRect(-healthWidth/2, -this.radius - 11, healthWidth, healthHeight);
          
          // Health percentage text
          ctx.fillStyle = '#ffffff';
          ctx.font = '10px MedievalSharp, cursive';
          ctx.textAlign = 'center';
          ctx.fillText(`${healthPercent}%`, 0, -this.radius - 13);
        }
        
        // ADD THE SELECTION RING CODE HERE
        if (this.selected) {
          // Smooth pulsing opacity
          const pulseAlpha = 0.4 + 0.4 * Math.sin(globalTime * 0.05);
          
          // Selection ring with glow
          ctx.strokeStyle = `rgba(245, 158, 11, ${pulseAlpha})`;
          ctx.lineWidth = 2;
          
          // Add glow effect
          ctx.shadowBlur = 15;
          ctx.shadowColor = 'rgba(245, 158, 11, 0.6)';
          
          ctx.beginPath();
          ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 5, 0, 2 * Math.PI);
          ctx.stroke();
          
          // Reset shadow
          ctx.shadowBlur = 0;
          
          // Inner ring for additional effect
          ctx.strokeStyle = `rgba(245, 158, 11, ${pulseAlpha * 0.5})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 8, 0, 2 * Math.PI);
          ctx.stroke();
        }
        
        ctx.restore();
      } 
      
      drawFoundation(ctx, currentHeight) {
        ctx.fillStyle = stonePattern;
        ctx.fillRect(-this.width/2, -currentHeight/2, this.width, currentHeight * 0.2);
        ctx.strokeStyle = '#4b5563';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.width/2, -currentHeight/2, this.width, currentHeight * 0.2);
        
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
          const x = -this.width/2 + Math.random() * this.width;
          const y = -currentHeight/2 + Math.random() * currentHeight * 0.2;
          const length = 5 + Math.random() * 15;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + (Math.random() - 0.5) * length, y + (Math.random() - 0.5) * length);
          ctx.stroke();
        }
      }
      
      drawMainStructure(ctx, currentHeight) {
        const woodHeight = currentHeight * 0.7;
        const woodY = -woodHeight/2 - currentHeight * 0.15;
        
        if (this.type === 'quarry') {
          ctx.fillStyle = stonePattern;
        } else if (this.type === 'lumbermill') {
          ctx.fillStyle = woodPattern;
        } else {
          ctx.fillStyle = woodPattern;
        }
        
        ctx.fillRect(-this.width/2 * 0.8, woodY, this.width * 0.8, woodHeight);
        ctx.strokeStyle = '#5a3921';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.width/2 * 0.8, woodY, this.width * 0.8, woodHeight);
        
        ctx.strokeStyle = '#4a3921';
        ctx.lineWidth = 1;
        const beamSpacing = this.width * 0.8 / 5;
        for (let i = 1; i <= 4; i++) {
          const x = -this.width/2 * 0.8 + i * beamSpacing;
          ctx.beginPath();
          ctx.moveTo(x, woodY);
          ctx.lineTo(x, woodY + woodHeight);
          ctx.stroke();
        }
        
        if (this.type === 'farm') {
          ctx.fillStyle = '#2E8B57';
          ctx.fillRect(-this.width/2 - 20, woodY + woodHeight, this.width + 40, 15);
          ctx.fillRect(-this.width/2 - 20, woodY - 15, this.width + 40, 15);
          
          ctx.fillStyle = '#32CD32';
          for (let i = 0; i < 20; i++) {
            const x = -this.width/2 - 15 + Math.random() * (this.width + 30);
            const y = woodY - 10 + Math.random() * 20;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (this.type === 'quarry') {
          ctx.fillStyle = '#808080';
          for (let i = 0; i < 15; i++) {
            const x = -this.width/2 + Math.random() * this.width;
            const y = woodY + Math.random() * woodHeight;
            const size = 3 + Math.random() * 7;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (this.type === 'lumbermill') {
          ctx.fillStyle = '#8B4513';
          for (let i = 0; i < 5; i++) {
            const x = -this.width/2 + 10 + i * 15;
            const y = woodY + woodHeight - 5;
            ctx.fillRect(x, y, 10, 5);
          }
          
          // Saw blade
          ctx.fillStyle = '#A9A9A9';
          ctx.beginPath();
          ctx.arc(0, woodY + woodHeight/2, 12, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = '#696969';
          ctx.lineWidth = 1;
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(0, woodY + woodHeight/2);
            ctx.lineTo(
              Math.cos(angle) * 12,
              woodY + woodHeight/2 + Math.sin(angle) * 12
            );
            ctx.stroke();
          }
        } else if (this.type === 'barracks') {
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(-this.width/2 * 0.8 + 10, woodY + 10, 5, woodHeight - 20);
          ctx.fillRect(-this.width/2 * 0.8 + this.width * 0.8 - 15, woodY + 10, 5, woodHeight - 20);
          
          ctx.fillStyle = '#A9A9A9';
          for (let i = 0; i < 3; i++) {
            const y = woodY + 20 + i * 15;
            ctx.fillRect(-this.width/2 * 0.8 + 5, y, 15, 3);
            ctx.fillRect(-this.width/2 * 0.8 + this.width * 0.8 - 20, y, 15, 3);
          }
          
          // Training yard
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(-this.width/2 - 20, woodY + woodHeight, this.width + 40, 10);
          
          // Training dummies
          ctx.fillStyle = '#A0522D';
          for (let i = 0; i < 3; i++) {
            const x = -this.width/2 - 10 + i * 30;
            ctx.fillRect(x, woodY + woodHeight - 20, 5, 20);
            ctx.beginPath();
            ctx.arc(x + 2.5, woodY + woodHeight - 25, 5, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (this.type === 'tower') {
          ctx.fillStyle = stonePattern;
          for (let i = 0; i < 5; i++) {
            const x = -this.width/2 * 0.8 + i * (this.width * 0.8 / 4);
            ctx.fillRect(x - 5, woodY - 10, 10, 10);
          }
          
          // Arrow slits
          ctx.fillStyle = '#000000';
          for (let i = 0; i < 3; i++) {
            const y = woodY + i * 15;
            ctx.fillRect(-3, y, 6, 10);
          }
        } else if (this.type === 'castle') {
          ctx.fillStyle = stonePattern;
          ctx.fillRect(-this.width/2 - 10, woodY - 20, 20, 30);
          ctx.fillRect(this.width/2 - 10, woodY - 20, 20, 30);
          ctx.fillRect(-this.width/2 - 10, woodY + woodHeight - 10, 20, 30);
          ctx.fillRect(this.width/2 - 10, woodY + woodHeight - 10, 20, 30);
          
          // Castle gate
          ctx.fillStyle = '#654321';
          ctx.fillRect(-15, woodY + woodHeight - 5, 30, 15);
          
          // Gate details
          ctx.fillStyle = '#4a3020';
          ctx.fillRect(-12, woodY + woodHeight - 2, 24, 2);
          ctx.fillRect(-12, woodY + woodHeight + 5, 24, 2);
          ctx.fillRect(-12, woodY + woodHeight + 12, 24, 2);
          
          // Castle flags
          for (let i = 0; i < 4; i++) {
            const x = -this.width/2 - 10 + (i % 2) * (this.width + 20);
            const y = woodY - 40 + Math.floor(i / 2) * 20;
            this.drawMiniFlag(ctx, x, y);
          }
        }
      }
      
      drawRoof(ctx, currentHeight) {
        let roofPeak = this.type === 'townhall' ? this.width * 0.5 : 
                      this.type === 'house' ? this.width * 0.4 :
                      this.type === 'barracks' ? this.width * 0.3 :
                      this.type === 'tower' ? 0 :
                      this.type === 'castle' ? this.width * 0.6 :
                      this.width * 0.4;
        
        if (this.type === 'tower') {
          ctx.fillStyle = stonePattern;
          ctx.fillRect(-this.width/2 * 0.8, -currentHeight * 0.5, this.width * 0.8, 10);
          
          // Tower battlements
          for (let i = 0; i < 4; i++) {
            const x = -this.width/2 * 0.8 + i * (this.width * 0.8 / 3);
            ctx.fillRect(x - 3, -currentHeight * 0.5 - 5, 6, 5);
          }
        } else {
          ctx.fillStyle = this.type === 'castle' ? stonePattern : '#78350f';
          ctx.beginPath();
          ctx.moveTo(-this.width/2 * 0.9, -currentHeight * 0.5);
          ctx.lineTo(0, -currentHeight * 0.5 - roofPeak);
          ctx.lineTo(this.width/2 * 0.9, -currentHeight * 0.5);
          ctx.closePath();
          ctx.fill();
          
          ctx.strokeStyle = '#5a3921';
          ctx.lineWidth = 1;
          const tileSpacing = this.width * 0.05;
          for (let i = -this.width/2 * 0.9; i <= this.width/2 * 0.9; i += tileSpacing) {
            const tileWidth = tileSpacing * 1.2;
            ctx.beginPath();
            ctx.moveTo(i, -currentHeight * 0.5);
            ctx.lineTo(i + tileWidth/2, -currentHeight * 0.5 - roofPeak * 0.3);
            ctx.lineTo(i + tileWidth, -currentHeight * 0.5);
            ctx.stroke();
          }
          
          // Roof decorations
          if (this.type === 'townhall') {
            // Weather vane
            ctx.fillStyle = '#A9A9A9';
            ctx.fillRect(-2, -currentHeight * 0.5 - roofPeak - 5, 4, 15);
            
            ctx.beginPath();
            ctx.moveTo(0, -currentHeight * 0.5 - roofPeak - 5);
            ctx.lineTo(-8, -currentHeight * 0.5 - roofPeak - 10);
            ctx.lineTo(0, -currentHeight * 0.5 - roofPeak - 8);
            ctx.closePath();
            ctx.fill();
          }
        }
        
        if (this.hasChimney && this.constructionProgress >= 100) {
          ctx.fillStyle = stonePattern;
          ctx.fillRect(this.type === 'lumbermill' ? 30 : 20, -currentHeight * 0.5 - 10, 15, 20);
          ctx.strokeStyle = '#4b5563';
          ctx.strokeRect(this.type === 'lumbermill' ? 30 : 20, -currentHeight * 0.5 - 10, 15, 20);
          
          // Chimney top
          ctx.fillStyle = '#5a3921';
          ctx.fillRect(this.type === 'lumbermill' ? 28 : 18, -currentHeight * 0.5 - 12, 19, 3);
        }
      }
      
      drawDetails(ctx, currentHeight) {
        const windowSize = this.width * 0.12;
        const windowY = -currentHeight * 0.25;
        
        if (this.type !== 'tower' && this.type !== 'quarry') {
          ctx.fillStyle = '#5a3921';
          ctx.fillRect(-this.width * 0.3 - 2, windowY - 2, windowSize + 4, windowSize + 4);
          ctx.fillRect(this.width * 0.15 - 2, windowY - 2, windowSize + 4, windowSize + 4);
          
          ctx.save();
          ctx.translate(-this.width * 0.3, windowY);
          this.drawStainedGlass(ctx, windowSize);
          ctx.restore();
          
          ctx.save();
          ctx.translate(this.width * 0.15, windowY);
          this.drawStainedGlass(ctx, windowSize);
          ctx.restore();
        }
        
        ctx.fillStyle = '#5a3921';
        ctx.fillRect(-this.width * 0.1, currentHeight * 0.1, this.width * 0.2, currentHeight * 0.3);
        ctx.strokeStyle = '#3a2911';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.width * 0.1, currentHeight * 0.1, this.width * 0.2, currentHeight * 0.3);
        
        ctx.fillStyle = '#b58a3a';
        ctx.beginPath();
        ctx.arc(-this.width * 0.02, currentHeight * 0.15, 3, 0, Math.PI * 2);
        ctx.fill();
        
        const isNight = dayNightCycle > 500 && dayNightCycle < 750;
        if (isNight && globalTime % 1000 < 500) {
          const lightRadius = 25 + Math.random() * 3 * this.lightFlicker;
          const gradient = ctx.createRadialGradient(
            -this.width * 0.02, currentHeight * 0.15, 3,
            -this.width * 0.02, currentHeight * 0.15, lightRadius
          );
          gradient.addColorStop(0, 'rgba(255, 180, 40, 0.6)');
          gradient.addColorStop(0.7, 'rgba(255, 120, 30, 0.2)');
          gradient.addColorStop(1, 'rgba(255, 80, 20, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(-this.width * 0.02, currentHeight * 0.15, lightRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        
        if (this.type === 'barracks') {
          this.drawFlag(ctx, 0, -currentHeight * 0.5 - 30, '#ef4444');
        } else if (this.type === 'townhall') {
          this.drawFlag(ctx, 20, -currentHeight * 0.5 - 40, '#f59e0b');
        } else if (this.type === 'castle') {
          this.drawFlag(ctx, 40, -currentHeight * 0.5 - 50, '#8b5cf6');
        }
        
        if (this.type === 'farm') {
          // Farm animals
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(-this.width * 0.3, currentHeight * 0.3, 4, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = '#FF0000';
          ctx.beginPath();
          ctx.arc(-this.width * 0.3 - 1, currentHeight * 0.3 - 1, 1, 0, Math.PI * 2);
          ctx.fill();
          
          // Fence
          ctx.fillStyle = '#8B4513';
          for (let i = 0; i < 8; i++) {
            const x = -this.width/2 - 15 + i * 15;
            ctx.fillRect(x, currentHeight * 0.4, 3, 10);
          }
          
          ctx.fillStyle = '#A0522D';
          ctx.fillRect(-this.width/2 - 15, currentHeight * 0.45, 105, 2);
        }
      }
      
      drawStainedGlass(ctx, size) {
        const segments = 4;
        const segmentSize = size / segments;
        
        for (let y = 0; y < segments; y++) {
          for (let x = 0; x < segments; x++) {
            ctx.fillStyle = this.windowColors[(x + y) % this.windowColors.length];
            ctx.beginPath();
            ctx.moveTo(x * segmentSize, y * segmentSize + segmentSize/2);
            ctx.lineTo(x * segmentSize + segmentSize/2, y * segmentSize);
            ctx.lineTo(x * segmentSize + segmentSize, y * segmentSize + segmentSize/2);
            ctx.lineTo(x * segmentSize + segmentSize/2, y * segmentSize + segmentSize);
            ctx.closePath();
            ctx.fill();
          }
        }
        
        ctx.strokeStyle = '#3a2911';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(size/2, 0);
        ctx.lineTo(size/2, size);
        ctx.moveTo(0, size/2);
        ctx.lineTo(size, size/2);
        ctx.stroke();
      }
      
      drawFlag(ctx, x, y, color) {
        ctx.save();
        ctx.translate(x, y);
        
        // Flag pole
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(-1, 0, 2, 30);
        
        // Flag
        ctx.save();
        ctx.translate(1, 5);
        ctx.rotate(this.bannerWave);
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 5);
        ctx.lineTo(20, 15);
        ctx.lineTo(0, 10);
        ctx.closePath();
        ctx.fill();
        
        // Flag emblem
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(10, 7.5, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        ctx.restore();
      }
      
      drawMiniFlag(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        
        // Flag pole
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(-0.5, 0, 1, 15);
        
        // Flag
        ctx.save();
        ctx.translate(0.5, 2);
        ctx.rotate(this.bannerWave);
        
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(10, 2);
        ctx.lineTo(10, 8);
        ctx.lineTo(0, 6);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        ctx.restore();
      }
      
      drawConstructionProgress(ctx, currentHeight) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(-this.width/2, -currentHeight/2 - 15, this.width, 10);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(-this.width/2, -currentHeight/2 - 15, this.width * (this.constructionProgress/100), 10);
        
        if (this.constructionProgress < 95) {
          const workerX = -this.width/2 + (this.width * (this.constructionProgress/100));
          const workerY = -currentHeight/2 - 10;
          const headBob = Math.sin(globalTime * 0.2) * 2;
          
          ctx.fillStyle = '#78350f';
          ctx.fillRect(workerX - 5, workerY + headBob, 10, 12);
          
          ctx.fillStyle = '#fcd34d';
          ctx.beginPath();
          ctx.arc(workerX, workerY + headBob, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Tool
          ctx.fillStyle = '#A9A9A9';
          ctx.fillRect(workerX + 5, workerY + headBob - 2, 8, 2);
        }
      }
      
      drawSmoke(ctx) {
        ctx.save();
        this.smokeParticles.forEach(p => {
          const alpha = Math.min(p.lifetime / 100, 0.6);
          const sizeVariation = Math.sin(p.lifetime * 0.1) * 0.5;
          
          const gradient = ctx.createRadialGradient(
            p.x - this.x, p.y - this.y, 0,
            p.x - this.x, p.y - this.y, p.size + sizeVariation
          );
          gradient.addColorStop(0, `rgba(220, 220, 220, ${alpha})`);
          gradient.addColorStop(1, `rgba(180, 180, 180, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x - this.x, p.y - this.y, p.size + sizeVariation, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.restore();
      }
      
      drawTorchParticles(ctx) {
        ctx.save();
        this.torchParticles.forEach(p => {
          const alpha = p.lifetime / 40;
          
          const gradient = ctx.createRadialGradient(
            p.x, p.y, 0,  // Fixed: use particle positions directly
            p.x, p.y, p.size
          );
          gradient.addColorStop(0, `rgba(255, 180, 40, ${alpha})`);
          gradient.addColorStop(1, `rgba(255, 80, 20, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);  // Fixed: use particle positions directly
          ctx.fill();
        });
        ctx.restore();
      }
      
      repair(amount) {
        const actualRepair = Math.min(amount, this.maxHealth - this.health);
        this.health += actualRepair;
        
        // Create repair particles
        particleSystem.createBurst(this.x, this.y, 'sparkle', 5);
        
        return actualRepair;
      }
      
      repairBuilding(building) {
        // Only builders can repair
        if (this.type !== 'builder') return false;
        
        // Check if builder is close enough to building
        const dist = Math.hypot(building.x - this.x, building.y - this.y);
        if (dist > Math.max(building.width, building.height) / 2 + this.radius + 10) {
          return false;
        }
        
        // Check if building needs repair
        if (building.health >= building.maxHealth) return false;
        
        // Repair building (costs wood)
        const repairAmount = 2;
        const woodCost = 1;
        
        if (resources.wood >= woodCost) {
          resources.wood -= woodCost;
          building.repair(repairAmount);
          updateResourceDisplay();
          return true;
        }
        
        return false;
      }
    }
    
    // Movement marker class with enhanced visuals
    class MovementMarker {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.baseRadius = 15;
        this.lifetime = 100;
        this.maxLifetime = 100;
        this.rotation = Math.random() * Math.PI * 2;
        this.path2dArrow = this._buildArrowPath();
      }
      
      // Pre-build a single arrow Path2D for performance
      _buildArrowPath() {
        const p = new Path2D();
        p.moveTo(0, -this.baseRadius * 0.6);
        p.lineTo(-this.baseRadius * 0.2, -this.baseRadius * 0.3);
        p.lineTo(this.baseRadius * 0.2, -this.baseRadius * 0.3);
        p.closePath();
        return p;
      }
      
      update() {
        this.lifetime--;
        this.rotation += 0.15 + (1 - this.lifetime / this.maxLifetime) * 0.1;
        return this.lifetime > 0;
      }
      
      draw(ctx) {
        const t = this.lifetime / this.maxLifetime; // 1 → 0
        const alpha = Math.pow(t, 2) * 0.8; // ease-out fade
        const pulse = 1 + Math.sin((1 - t) * Math.PI * 2) * 0.15; // subtle breathing
        const r = this.baseRadius * (pulse + (1 - t) * 0.3); // expand over time
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Outer dashed ring
        ctx.setLineDash([4, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = `rgba(245, 158, 11, ${alpha})`;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Inner arrows (4), reusing the Path2D
        ctx.fillStyle = `rgba(245, 158, 11, ${alpha})`;
        for (let i = 0; i < 4; i++) {
          ctx.fill(this.path2dArrow);
          ctx.rotate(Math.PI / 2);
        }
        
        ctx.restore();
      }
    }
    
    // Projectile class for combat
    class Projectile {
      constructor(x, y, targetX, targetY, damage, speed, owner) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.damage = damage;
        this.speed = speed;
        this.owner = owner; // Unit or building that fired this projectile
        this.radius = 3;
        this.lifetime = 100;
        
        // Calculate direction
        const dx = targetX - x;
        const dy = targetY - y;
        const dist = Math.hypot(dx, dy);
        this.velocity = {
          x: (dx / dist) * speed,
          y: (dy / dist) * speed
        };
      }
      
      update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.lifetime--;
        
        // Check if projectile hit its target or expired
        if (this.lifetime <= 0) {
          return false;
        }
        
        // Check collision with enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
          if (dist < enemy.radius + this.radius) {
            enemy.health -= this.damage;
            
            // Create impact particles
            particleSystem.createBurst(this.x, this.y, 'blood', 5);
            
            if (enemy.health <= 0) {
              enemies.splice(i, 1);
              // Death particles
              particleSystem.createBurst(enemy.x, enemy.y, 'blood', 15);
              
              // Reward resources for defeating enemy
              resources.wood += 5;
              resources.stone += 3;
              resources.food += 2;
              updateResourceDisplay();
            }
            
            return false;
          }
        }
        
        return true;
      }
      
      draw(ctx) {
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Initialize game
    function init() {
      // Initialize audio system
      initAudio();
      
      // Initialize grass variants
      initGrassVariants();
      
      // Try to load saved game
      if (loadGame()) {
        // Center camera on first unit if exists
        if (units.length > 0) {
          camera.x = units[0].x - canvas.width / 2;
          camera.y = units[0].y - canvas.height / 2;
          clampCamera();
        }
        return;
      }
      
      // Place units somewhere within the huge world
      units.push(new Unit(150, 150, "settler"));
      units.push(new Unit(200, 150, "warrior"));
      
      // Place resource nodes
      for (let i = 0; i < 20; i++) {
        resourceNodes.push(new ResourceNode(
          100 + Math.random() * (worldWidth - 200),
          100 + Math.random() * (worldHeight - 200),
          'tree'
        ));
      }
      
      for (let i = 0; i < 15; i++) {
        resourceNodes.push(new ResourceNode(
          100 + Math.random() * (worldWidth - 200),
          100 + Math.random() * (worldHeight - 200),
          'rock'
        ));
      }
      
      for (let i = 0; i < 10; i++) {
        resourceNodes.push(new ResourceNode(
          100 + Math.random() * (worldWidth - 200),
          100 + Math.random() * (worldHeight - 200),
          'bush'
        ));
      }
      
      // Initially center the camera on the first unit
      camera.x = units[0].x - canvas.width / 2;
      camera.y = units[0].y - canvas.height / 2;
      clampCamera();
      
      // Show initial quest
      showQuestNotification(questState.mainQuest);
      playSound('quest');
      
      // Update resource display
      updateResourceDisplay();
    }
    
    // Auto-save functionality
    function saveGame() {
      const saveData = {
        resources: resources,
        buildings: buildings.map(b => ({
          type: b.type,
          x: b.x,
          y: b.y,
          constructionProgress: b.constructionProgress,
          health: b.health,
          maxHealth: b.maxHealth
        })),
        units: units.map(u => ({
          type: u.type,
          x: u.x,
          y: u.y,
          targetX: u.targetX,
          targetY: u.targetY,
          health: u.health,
          maxHealth: u.maxHealth
        })),
        dayNightCycle: dayNightCycle,
        currentDay: currentDay,
        questState: questState,
        enemyWaveNumber: enemyWaveNumber,
        settlementEstablished: settlementEstablished,
        territories: territories
      };
      
      localStorage.setItem('medievalGodGameSave', JSON.stringify(saveData));
    }
    
    function loadGame() {
      const saveData = localStorage.getItem('medievalGodGameSave');
      if (!saveData) return false;
      
      try {
        const data = JSON.parse(saveData);
        
        // Clear existing arrays
        buildings.length = 0;
        units.length = 0;
        enemies.length = 0;
        resourceNodes.length = 0;
        territories.length = 0;
        
        // Restore resources
        resources = data.resources;
        
        // Restore buildings and check for Town Hall
        data.buildings.forEach(bData => {
          const building = new Building(bData.x, bData.y, bData.type);
          building.constructionProgress = bData.constructionProgress;
          building.health = bData.health;
          building.maxHealth = bData.maxHealth;
          buildings.push(building);
          
          // Set townHallBuilt flag if Town Hall exists and is complete
          if (bData.type === 'townhall' && bData.constructionProgress >= 100) {
            townHallBuilt = true;
          }
        });
        
        // Restore units
        data.units.forEach(uData => {
          const unit = new Unit(uData.x, uData.y, uData.type);
          unit.targetX = uData.targetX;
          unit.targetY = uData.targetY;
          unit.health = uData.health;
          unit.maxHealth = uData.maxHealth;
          units.push(unit);
        });
        
        // Restore other state
        dayNightCycle = data.dayNightCycle;
        currentDay = data.currentDay;
        questState = data.questState;
        enemyWaveNumber = data.enemyWaveNumber;
        settlementEstablished = data.settlementEstablished;
        territories = data.territories;
        
        // Update UI
        updateResourceDisplay();
        
        return true;
      } catch (e) {
        console.error('Failed to load game:', e);
        return false;
      }
    }
    
    // Auto-save every 30 seconds
    setInterval(saveGame, 30000);
    
    function addResetButton() {
      // Create a hover area that's completely off-screen
      const hoverArea = document.createElement('div');
      Object.assign(hoverArea.style, {
        position: 'absolute',
        bottom: '20px',
        left: '0',              // Start at the left edge
        width: '20px',           // 20px wide hover area
        height: '40px',          // 40px tall
        zIndex: 20,
      });
      
      // Create the button container
      const container = document.createElement('div');
      Object.assign(container.style, {
        position: 'absolute',
        bottom: '20px',
        left: '-120px',          // Start completely off-screen
        width: '100px',
        height: '40px',
        transition: 'left 0.3s ease',
        zIndex: 20,
      });
      
      // Create the reset button
      const resetButton = document.createElement('button');
      resetButton.textContent = 'Reset Game';
      resetButton.style.cssText = `
        width: 100%;
        height: 100%;
        background-color: #b91c1c;
        color: white;
        border: none;
        border-radius: 0.375rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        cursor: pointer;
        font-family: 'Cinzel', serif;
        font-weight: bold;
      `;
      
      // Add hover effect for the button
      resetButton.addEventListener('mouseover', () => {
        resetButton.style.backgroundColor = '#dc2626';
      });
      
      resetButton.addEventListener('mouseout', () => {
        resetButton.style.backgroundColor = '#b91c1c';
      });
      
      // Add click handler
      resetButton.addEventListener('click', () => {
        if (confirm('Are you sure you want to reset the game? All progress will be lost.')) {
          localStorage.removeItem('medievalGodGameSave');
          location.reload();
        }
      });
      
      // Show the button when hovering over the hover area
      hoverArea.addEventListener('mouseenter', () => {
        container.style.left = '20px';
      });
      
      // Hide the button when mouse leaves the button
      container.addEventListener('mouseleave', () => {
        container.style.left = '-120px';
      });
      
      // Assemble the elements
      container.appendChild(resetButton);
      document.body.appendChild(hoverArea);
      document.body.appendChild(container);
    }
    
    // Call this after init()
    addResetButton();
    
    // Update resource display
    function updateResourceDisplay() {
      // Ensure resources don't go negative
      resources.wood = Math.max(0, resources.wood);
      resources.stone = Math.max(0, resources.stone);
      resources.food = Math.max(0, resources.food);
      resources.population = Math.max(0, resources.population);
      
      document.getElementById('woodCount').textContent = resources.wood;
      document.getElementById('stoneCount').textContent = resources.stone;
      document.getElementById('foodCount').textContent = resources.food;
      document.getElementById('populationCount').textContent = `${resources.population}/${resources.populationCap}`;
    }
    
    // Show quest notification
    function showQuestNotification(text) {
      const notification = document.getElementById('questNotification');
      const questText = document.getElementById('questText');
      
      questText.textContent = text;
      notification.classList.remove('hidden');
      
      setTimeout(() => {
        notification.classList.add('hidden');
      }, 2500);
    }
    
    // Spawn enemy wave
    function spawnEnemyWave() {
      isWaveActive = true;
      enemyWaveTimer = 0;
      
      // Determine number of enemies based on wave number
      const enemyCount = 3 + enemyWaveNumber * 2;
      
      // Spawn enemies at random edges of the map
      for (let i = 0; i < enemyCount; i++) {
        const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
        let x, y;
        
        switch(side) {
          case 0: // top
            x = Math.random() * worldWidth;
            y = 50;
            break;
          case 1: // right
            x = worldWidth - 50;
            y = Math.random() * worldHeight;
            break;
          case 2: // bottom
            x = Math.random() * worldWidth;
            y = worldHeight - 50;
            break;
          case 3: // left
            x = 50;
            y = Math.random() * worldHeight;
            break;
        }
        
        // Enemy type based on wave number
        const type = enemyWaveNumber < 3 ? 'wolf' : 
                    enemyWaveNumber < 7 ? Math.random() > 0.5 ? 'raider' : 'wolf' : 
                    'raider';
        
        enemies.push(new Enemy(x, y, type));
      }
      
      showQuestNotification(`Wave ${enemyWaveNumber} incoming! Prepare your defenses!`);
      playSound('quest');
    }
    
    // Clamp camera so it doesn't show beyond the world
    function clampCamera() {
      camera.x = Math.max(0, Math.min(camera.x, worldWidth - canvas.width));
      camera.y = Math.max(0, Math.min(camera.y, worldHeight - canvas.height));
    }
    
    // Check if a position is within any territory
    function isInTerritory(x, y) {
      for (const territory of territories) {
        const dist = Math.hypot(territory.x - x, territory.y - y);
        if (dist <= territory.radius) {
          return true;
        }
      }
      return false;
    }
    
    // Handle mouse clicks on canvas to select units or command movement/attack
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // First check if click was on minimap
      if (isClickOnMinimap(mouseX, mouseY)) {
        handleMinimapClick(mouseX, mouseY);
        return;
      }
      
      // Convert screen coordinates to world coordinates
      const worldMouseX = mouseX + camera.x;
      const worldMouseY = mouseY + camera.y;
      
      // Check if in building placement mode
      if (buildingPlacementMode && selectedBuildingType) {
        // Check if we can afford the building
        const cost = buildingCosts[selectedBuildingType];
        if (resources.wood >= cost.wood && resources.stone >= cost.stone) {
          // Check if location is valid
          let canBuild = isInTerritory(worldMouseX, worldMouseY);
          
          if (canBuild) {
            for (const building of buildings) {
              const dist = Math.hypot(building.x - worldMouseX, building.y - worldMouseY);
              if (dist < 100) {
                canBuild = false;
                break;
              }
            }
          }
          
          if (canBuild) {
            // Store the planned building data in the builder
            if (selectedUnit && selectedUnit.type === 'builder') {
              selectedUnit.plannedBuilding = {
                x: worldMouseX,
                y: worldMouseY,
                type: selectedBuildingType
              };
              selectedUnit.targetX = worldMouseX;
              selectedUnit.targetY = worldMouseY;
              
              // Create placement particles
              particleSystem.createBurst(worldMouseX, worldMouseY, 'sparkle', 10);
              playSound('click');
            }
            
            // Exit building placement mode
            buildingPlacementMode = false;
            selectedBuildingType = null;
            customCursor.type = 'default';
            document.getElementById('buildingMenu').classList.add('hidden');
          } else {
            showQuestNotification(
              "Cannot build here! Must be within your territory and not too close to other buildings."
            );
            playSound('damage');
          }
        } else {
          showQuestNotification(
            `Not enough resources! Need ${cost.wood} wood and ${cost.stone} stone.`
          );
          playSound('damage');
        }
        return;
      }
      
      // Check if clicked on a unit (with improved selection logic)
      let clickedUnit = null;
      let closestUnitDist = Infinity;
      
      // First, check all units to find the closest one to the click
      for (let unit of units) {
        const dist = Math.hypot(unit.x - worldMouseX, unit.y - worldMouseY);
        if (dist <= unit.radius && dist < closestUnitDist) {
          clickedUnit = unit;
          closestUnitDist = dist;
        }
      }
      
      if (clickedUnit) {
        // Select the unit
        if (selectedUnit) {
          selectedUnit.selected = false;
        }
        
        if (selectedBuilding) {
          selectedBuilding.selected = false;
          selectedBuilding = null;
        }
        
        selectedUnit = clickedUnit;
        selectedUnit.selected = true;
        
        if (
          clickedUnit.type === 'warrior' ||
          clickedUnit.type === 'archer' ||
          clickedUnit.type === 'knight'
        ) {
          triggerShake(10, 4);
        }
        
        updateUnitInfo();
        playSound('select');
        
        // Selection particles
        particleSystem.createBurst(selectedUnit.x, selectedUnit.y, 'sparkle', 10);
        return;
      }
      
      // --- New enemy-click detection block ---
      // If a combat unit is selected, check if click is on an enemy before selecting a building.
      if (selectedUnit && selectedUnit.type !== 'worker') {
        let clickedEnemy = null;
        let closestEnemyDist = Infinity;
        for (const enemy of enemies) {
          const dist = Math.hypot(enemy.x - worldMouseX, enemy.y - worldMouseY);
          // Consider the enemy clicked if within its radius (add a small buffer if needed)
          if (dist <= enemy.radius && dist < closestEnemyDist) {
            clickedEnemy = enemy;
            closestEnemyDist = dist;
          }
        }
        if (clickedEnemy) {
          // Set target coordinates to the enemy's position so the unit will chase and attack
          selectedUnit.targetX = clickedEnemy.x;
          selectedUnit.targetY = clickedEnemy.y;
          // Add a movement marker for visual feedback
          movementMarkers.push(new MovementMarker(clickedEnemy.x, clickedEnemy.y));
          playSound('attack');
          return; // Skip building selection
        }
      }
      // --- End of enemy-click detection block ---
      
      // If no unit was clicked, check for buildings
      let clickedBuilding = null;
      for (let building of buildings) {
        const dist = Math.hypot(building.x - worldMouseX, building.y - worldMouseY);
        if (dist <= Math.max(building.width, building.height) / 2) {
          clickedBuilding = building;
          break;
        }
      }
      
      if (clickedBuilding) {
        // Select building
        if (selectedUnit) {
          selectedUnit.selected = false;
          selectedUnit = null;
        }
        
        if (selectedBuilding) {
          selectedBuilding.selected = false;
        }
        
        selectedBuilding = clickedBuilding;
        selectedBuilding.selected = true;
        updateBuildingInfo();
        playSound('select');
        
        // Selection particles
        particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
        return;
      }
      
      // Check if clicked on a resource node
      let clickedResource = null;
      for (let resource of resourceNodes) {
        const dist = Math.hypot(resource.x - worldMouseX, resource.y - worldMouseY);
        if (dist <= resource.radius && resource.amount > 0) {
          clickedResource = resource;
          break;
        }
      }
      
      if (clickedResource && selectedUnit && selectedUnit.type === 'worker') {
        // Command worker to gather resource
        selectedUnit.targetResource = clickedResource;
        selectedUnit.targetX = clickedResource.x;
        selectedUnit.targetY = clickedResource.y;
        selectedUnit.state = 'moving_to_resource';
        selectedUnit.currentLoad = { wood: 0, stone: 0, food: 0 };
        
        // Add movement marker
        movementMarkers.push(new MovementMarker(worldMouseX, worldMouseY));
        
        // Add particles
        particleSystem.createBurst(worldMouseX, worldMouseY, 'sparkle', 5);
        playSound('click');
        
        updateUnitInfo();
        return;
      }
      
      // Command selected unit to move (if not a worker)
      if (selectedUnit && selectedUnit.type !== 'worker') {
        selectedUnit.targetX = worldMouseX;
        selectedUnit.targetY = worldMouseY;
        
        // Add movement marker and particles
        movementMarkers.push(new MovementMarker(worldMouseX, worldMouseY));
        particleSystem.createBurst(worldMouseX, worldMouseY, 'sparkle', 8);
        playSound('move');
        
        updateUnitInfo();
      }
    });
    
    // Right click to deselect unit/building or cancel building placement
    canvas.addEventListener("contextmenu", function(e) {
      e.preventDefault(); // Prevent context menu
      
      if (buildingPlacementMode) {
        buildingPlacementMode = false;
        selectedBuildingType = null;
        document.getElementById('buildingMenu').classList.add('hidden');
        restoreBuilderInfo();
        customCursor.type = 'default';
        return;
      }
      
      if (selectedUnit) {
        selectedUnit.selected = false;
        selectedUnit = null;
        updateUnitInfo();
      }
      
      if (selectedBuilding) {
        selectedBuilding.selected = false;
        selectedBuilding = null;
        updateBuildingInfo();
      }
    });
    
    // Check if click is on minimap
    function isClickOnMinimap(mouseX, mouseY) {
      const minimapWidth = 200;
      const minimapHeight = 200;
      const minimapX = canvas.width - minimapWidth - 10;
      const minimapY = canvas.height - minimapHeight - 10;
      
      return mouseX >= minimapX && mouseX <= minimapX + minimapWidth &&
             mouseY >= minimapY && mouseY <= minimapY + minimapHeight;
    }
    
    // Handle minimap click - move camera to clicked position
    function handleMinimapClick(mouseX, mouseY) {
      const minimapWidth = 200;
      const minimapHeight = 200;
      const minimapX = canvas.width - minimapWidth - 10;
      const minimapY = canvas.height - minimapHeight - 10;
      
      // Calculate relative position within minimap
      const relX = mouseX - minimapX;
      const relY = mouseY - minimapY;
      
      // Convert to world coordinates
      const worldX = (relX / minimapWidth) * worldWidth;
      const worldY = (relY / minimapHeight) * worldHeight;
      
      // Center camera on this position
      camera.x = worldX - canvas.width / 2;
      camera.y = worldY - canvas.height / 2;
      clampCamera();
      
      // Add visual feedback
      particleSystem.createParticle(mouseX, mouseY, 'sparkle');
    }
    
    // Listen for arrow keys to scroll when no unit is selected
    window.addEventListener("keydown", function(e) {
      keysPressed[e.key] = true;
      
      if (e.key === "Escape") {
        if (buildingPlacementMode) {
          buildingPlacementMode = false;
          selectedBuildingType = null;
          document.getElementById('buildingMenu').classList.add('hidden');
          restoreBuilderInfo();
          customCursor.type = 'default';
        } else if (selectedUnit) {
          selectedUnit.selected = false;
          selectedUnit = null;
          updateUnitInfo();
        } else if (selectedBuilding) {
          selectedBuilding.selected = false;
          selectedBuilding = null;
          updateBuildingInfo();
        }
      }
      
      if ((e.key === "b" || e.key === "B") && selectedUnit && selectedUnit.type === 'builder') {
        const menu = document.getElementById('buildingMenu');
        menu.classList.toggle('hidden');
        
        // If menu is being opened, show the first building's details
        if (!menu.classList.contains('hidden')) {
          const firstBuildingBtn = menu.querySelector('.building-btn');
          if (firstBuildingBtn) {
            const buildingType = firstBuildingBtn.getAttribute('data-building');
            updateBuildingMenuInfo(buildingType);
          }
        } else {
          restoreBuilderInfo();
          customCursor.type = 'default';
        }
      }
    });
    
    window.addEventListener("keyup", function(e) {
      keysPressed[e.key] = false;
    });
    
    // Building menu button clicks
    document.querySelectorAll('.building-btn').forEach(button => {
      // Add mouseover event
      button.addEventListener('mouseover', function() {
        if (selectedUnit && selectedUnit.type === 'builder' && buildingPlacementMode) {
          const buildingType = this.getAttribute('data-building');
          updateBuildingMenuInfo(buildingType);
        }
      });
      
      // Add mouseout event
      button.addEventListener('mouseout', function() {
        if (selectedUnit && selectedUnit.type === 'builder' && buildingPlacementMode) {
          restoreBuilderInfo();
        }
      });
      
      // Keep the existing click event
      button.addEventListener('click', function() {
        const buildingType = this.getAttribute('data-building');
        const cost = buildingCosts[buildingType];
        
        if (resources.wood >= cost.wood && resources.stone >= cost.stone) {
          buildingPlacementMode = true;
          selectedBuildingType = buildingType;
          document.getElementById('buildingMenu').classList.add('hidden');
          
          // Show building details in the UI
          updateBuildingMenuInfo(buildingType);
          playSound('click');
        } else {
          showQuestNotification(`Not enough resources! Need ${cost.wood} wood and ${cost.stone} stone.`);
          playSound('damage');
        }
      });
    });
    
    // Update the UI panel with unit info and actions
    function updateUnitInfo() {
      const infoDiv = document.getElementById("unitInfo");
      
      if (selectedBuilding) {
        updateBuildingInfo();
        return;
      }
      
      if (!selectedUnit) {
        infoDiv.innerHTML = `
          <div class="flex justify-center mb-3">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-amber-400 animate-bounce" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
            </svg>
          </div>
          <p class="text-center">Select a unit to command</p>
        `;
        return;
      }
      
      // Calculate distance to target
      const dx = selectedUnit.targetX - selectedUnit.x;
      const dy = selectedUnit.targetY - selectedUnit.y;
      const dist = Math.hypot(dx, dy);
      const isMoving = dist > 2; // Use a small threshold to account for floating point imprecision
      
      let statusText = 'Idle';
      if (selectedUnit.type === 'worker') {
        switch(selectedUnit.state) {
          case 'idle':
            statusText = 'Idle';
            break;
          case 'moving_to_resource':
            statusText = 'Moving to Resource';
            break;
          case 'gathering':
            statusText = 'Gathering';
            break;
          case 'moving_to_storage':
            statusText = 'Returning to Storage';
            break;
          case 'depositing':
            statusText = 'Depositing Resources';
            break;
        }
      } else if (isMoving) {
        statusText = 'Moving';
      }
      
      const healthPercent = Math.round((selectedUnit.health / selectedUnit.maxHealth) * 100);
      const colorClass = healthPercent > 60
        ? 'bg-emerald-500'
        : healthPercent > 30
          ? 'bg-amber-500'
          : 'bg-red-500';
          
      let html = `
        <div class="mb-4">
          <h3 class="text-lg font-bold text-amber-200 border-b border-amber-700 pb-1 mb-2">
            ${selectedUnit.type === 'settler' ? '🛠️ Settler' : 
              selectedUnit.type === 'builder' ? '🔨 Builder' : 
              selectedUnit.type === 'worker' ? '⛏️ Worker' : 
              selectedUnit.type === 'warrior' ? '⚔️ Warrior' : 
              selectedUnit.type === 'archer' ? '🏹 Archer' : 
              '🛡️ Knight'}
          </h3>
          <div class="grid grid-cols-2 gap-2 text-sm">
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded">
              <div class="text-amber-300">Health</div>
              <div class="flex items-center">
                <div class="w-full bg-stone-700 rounded h-2 mr-2">
                  <div class="${colorClass} h-2 rounded" style="width:${healthPercent}%"></div>
                </div>
                <span>${selectedUnit.health}/${selectedUnit.maxHealth}</span>
              </div>
            </div>
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded">
              <div class="text-amber-300">Position</div>
              <div>${Math.round(selectedUnit.x)}, ${Math.round(selectedUnit.y)}</div>
            </div>
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded">
              <div class="text-amber-300">Target</div>
              <div>${Math.round(selectedUnit.targetX)}, ${Math.round(selectedUnit.targetY)}</div>
            </div>
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded">
              <div class="text-amber-300">Status</div>
              <div>${statusText}</div>
            </div>
          </div>
        </div>
      `;
      
      // For settler units, add a "Settle" button if not already settled
      if (selectedUnit.type === "settler") {
        html += `
          <button id="settleButton" class="w-full mt-2 px-4 py-2 bg-amber-700 hover:bg-amber-600 text-white rounded shadow transition-all duration-200 flex items-center justify-center pulse-animation border border-amber-500">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
            </svg>
            Settle & Build Town
          </button>
        `;
      }
      
      // For builder units, add building menu button
      if (selectedUnit.type === 'builder') {
        html += `
          <button id="buildingMenuButton" class="w-full mt-2 px-4 py-2 bg-amber-700 hover:bg-amber-600 text-white rounded shadow transition-all duration-200 flex items-center justify-center border border-amber-500">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
            </svg>
            Build Structures (B)
          </button>
        `;
      }
      
      if (selectedUnit.type === 'builder') {
        html += `
          <div class="mt-3">
            <h4 class="text-amber-300 text-sm mb-2">Repair Mode</h4>
            <div class="text-xs text-amber-100 mb-2">
              Builders automatically repair nearby damaged buildings for 1 wood per repair.
            </div>
          </div>
        `;
      }
      
      // For worker units, show current load and resource assignment
      if (selectedUnit.type === 'worker') {
        const totalLoad = selectedUnit.currentLoad.wood + selectedUnit.currentLoad.stone + selectedUnit.currentLoad.food;
        
        html += `
          <div class="mt-3 bg-stone-800 bg-opacity-50 p-2 rounded">
            <div class="text-amber-300 text-sm mb-1">Current Load</div>
            <div class="grid grid-cols-3 gap-1 text-xs">
              <div>Wood: ${selectedUnit.currentLoad.wood}</div>
              <div>Stone: ${selectedUnit.currentLoad.stone}</div>
              <div>Food: ${selectedUnit.currentLoad.food}</div>
            </div>
            <div class="mt-1 text-xs">Capacity: ${totalLoad}/${selectedUnit.carryCapacity}</div>
          </div>
        `;
        
        if (selectedUnit.state === 'idle') {
          html += `
            <div class="mt-2 text-xs text-amber-300">Click on a resource to assign this worker</div>
          `;
        }
      }
      
      // For military units, show attack stats
      if (selectedUnit.type === 'warrior' || selectedUnit.type === 'archer' || selectedUnit.type === 'knight') {
        html += `
          <div class="mt-3 bg-stone-800 bg-opacity-50 p-2 rounded">
            <div class="text-amber-300 text-sm mb-1">Combat Stats</div>
            <div class="grid grid-cols-2 gap-1 text-xs">
              <div>Damage: ${selectedUnit.damage}</div>
              <div>Range: ${selectedUnit.attackRange}</div>
              <div>Speed: ${selectedUnit.speed}</div>
              <div>Armor: ${selectedUnit.type === 'knight' ? 'High' : selectedUnit.type === 'warrior' ? 'Medium' : 'Low'}</div>
            </div>
          </div>
        `;
      }
      
      // For townhall, add unit production buttons
      if (selectedBuilding && selectedBuilding.type === 'townhall' && selectedBuilding.constructionProgress >= 100) {
        html += `
          <div class="mt-3">
            <h4 class="text-amber-300 text-sm mb-2">Train Units</h4>
            <div class="grid grid-cols-2 gap-2">
              <button id="trainSettler" class="px-2 py-1 bg-green-800 hover:bg-green-700 text-white rounded text-xs flex flex-col items-center">
                <span>Settler</span>
                <span class="text-amber-300">${unitCosts.settler.food} 🍖</span>
              </button>
              <button id="trainBuilder" class="px-2 py-1 bg-amber-800 hover:bg-amber-700 text-white rounded text-xs flex flex-col items-center">
                <span>Builder</span>
                <span class="text-amber-300">${unitCosts.builder.food} 🍖 ${unitCosts.builder.wood} 🪵</span>
              </button>
              <button id="trainWorker" class="px-2 py-1 bg-blue-800 hover:bg-blue-700 text-white rounded text-xs flex flex-col items-center">
                <span>Worker</span>
                <span class="text-amber-300">${unitCosts.worker.food} 🍖</span>
              </button>
              <button id="trainWarrior" class="px-2 py-1 bg-red-800 hover:bg-red-700 text-white rounded text-xs flex flex-col items-center">
                <span>Warrior</span>
                <span class="text-amber-300">${unitCosts.warrior.food} 🍖 ${unitCosts.warrior.wood} 🪵</span>
              </button>
            </div>
          </div>
        `;
      }
      
      // For barracks, add military unit production buttons
      if (selectedBuilding && selectedBuilding.type === 'barracks' && selectedBuilding.constructionProgress >= 100) {
        html += `
          <div class="mt-3">
            <h4 class="text-amber-300 text-sm mb-2">Train Units</h4>
            <div class="grid grid-cols-2 gap-2">
              <button id="trainArcher" class="px-2 py-1 bg-green-800 hover:bg-green-700 text-white rounded text-xs flex flex-col items-center">
                <span>Archer</span>
                <span class="text-amber-300">${unitCosts.archer.food} 🍖 ${unitCosts.archer.wood} 🪵</span>
              </button>
              <button id="trainKnight" class="px-2 py-1 bg-blue-800 hover:bg-blue-700 text-white rounded text-xs flex flex-col items-center">
                <span>Knight</span>
                <span class="text-amber-300">${unitCosts.knight.food} 🍖 ${unitCosts.knight.wood} 🪵 ${unitCosts.knight.stone} 🪨</span>
              </button>
            </div>
          </div>
        `;
      }
      
      infoDiv.innerHTML = html;
      
      // Add event listeners for buttons
      // Modify the settler's settle button click handler
      const settleButton = document.getElementById("settleButton");
      if (settleButton) {
        settleButton.addEventListener("click", function() {
          // Check if we already have a town hall
          if (townHallBuilt) {
            showQuestNotification("You already have a Town Hall! Only one is allowed.");
            playSound('damage');
            return;
          }
          
          buildings.push(new Building(selectedUnit.x, selectedUnit.y, 'townhall'));
          settlementEstablished = true;
          const index = units.indexOf(selectedUnit);
          if (index > -1) {
            units.splice(index, 1);
            resources.population--;
            updateResourceDisplay();
          }
          
          // Settlement particles
          particleSystem.createBurst(buildings[buildings.length-1].x, buildings[buildings.length-1].y, 'sparkle', 30);
          particleSystem.createBurst(buildings[buildings.length-1].x, buildings[buildings.length-1].y, 'smoke', 15);
          playSound('build');
          
          selectedUnit = null;
          updateUnitInfo();
        });
      }
      
      // Modify the building menu toggle to show building details when opened
      const originalBuildingMenuButtonHandler = function() {
        const menu = document.getElementById('buildingMenu');
        menu.classList.toggle('hidden');
        
        // If menu is being opened and no building is selected, show the first building's details
        if (!menu.classList.contains('hidden') && selectedUnit && selectedUnit.type === 'builder') {
          const firstBuildingBtn = menu.querySelector('.building-btn');
          if (firstBuildingBtn) {
            const buildingType = firstBuildingBtn.getAttribute('data-building');
            updateBuildingMenuInfo(buildingType);
          }
        }
      };
      
      // Update the building menu button event listener
      const buildingMenuButton = document.getElementById("buildingMenuButton");
      if (buildingMenuButton) {
        buildingMenuButton.addEventListener("click", function() {
          const menu = document.getElementById('buildingMenu');
          const isMenuHidden = menu.classList.contains('hidden');
          
          if (isMenuHidden) {
            // Opening the menu
            menu.classList.remove('hidden');
            buildingPlacementMode = true;
            selectedBuildingType = null;
            customCursor.type = 'build';
            
            // Show default message
            const infoDiv = document.getElementById("unitInfo");
            infoDiv.innerHTML = `
              <div class="text-center">
                <p class="text-amber-300">Hover over a building to see details</p>
              </div>
            `;
            
            // Force hover state on first building button
            setTimeout(() => {
              const firstBuildingBtn = menu.querySelector('.building-btn');
              if (firstBuildingBtn) {
                // Create and dispatch a mouseover event
                const event = new MouseEvent('mouseover', {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                firstBuildingBtn.dispatchEvent(event);
              }
            }, 10); // Small delay to ensure menu is visible
          } else {
            // Closing the menu
            menu.classList.add('hidden');
            buildingPlacementMode = false;
            selectedBuildingType = null;
            customCursor.type = 'default';
            restoreBuilderInfo();
          }
        });
      }
      
      // Unit training buttons
      const trainSettler = document.getElementById("trainSettler");
      if (trainSettler) {
        trainSettler.addEventListener("click", function() {
          if (resources.food >= unitCosts.settler.food && resources.population < resources.populationCap) {
            resources.food -= unitCosts.settler.food;
            resources.population++;
            updateResourceDisplay();
            
            // Create new settler near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'settler'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough food!");
            playSound('damage');
          }
        });
      }
      
      const trainBuilder = document.getElementById("trainBuilder");
      if (trainBuilder) {
        trainBuilder.addEventListener("click", function() {
          if (resources.food >= unitCosts.builder.food && 
              resources.wood >= unitCosts.builder.wood && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.builder.food;
            resources.wood -= unitCosts.builder.wood;
            resources.population++;
            updateResourceDisplay();
            
            // Create new builder near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'builder'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
      
      const trainWorker = document.getElementById("trainWorker");
      if (trainWorker) {
        trainWorker.addEventListener("click", function() {
          if (resources.food >= unitCosts.worker.food && resources.population < resources.populationCap) {
            resources.food -= unitCosts.worker.food;
            resources.population++;
            updateResourceDisplay();
            
            // Create new worker near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'worker'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough food!");
            playSound('damage');
          }
        });
      }
      
      const trainWarrior = document.getElementById("trainWarrior");
      if (trainWarrior) {
        trainWarrior.addEventListener("click", function() {
          if (resources.food >= unitCosts.warrior.food && 
              resources.wood >= unitCosts.warrior.wood && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.warrior.food;
            resources.wood -= unitCosts.warrior.wood;
            resources.population++;
            updateResourceDisplay();
            
            // Create new warrior near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'warrior'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
      
      const trainArcher = document.getElementById("trainArcher");
      if (trainArcher) {
        trainArcher.addEventListener("click", function() {
          if (resources.food >= unitCosts.archer.food && 
              resources.wood >= unitCosts.archer.wood && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.archer.food;
            resources.wood -= unitCosts.archer.wood;
            resources.population++;
            updateResourceDisplay();
            
            // Create new archer near barracks
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'archer'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
      
      const trainKnight = document.getElementById("trainKnight");
      if (trainKnight) {
        trainKnight.addEventListener("click", function() {
          if (resources.food >= unitCosts.knight.food && 
              resources.wood >= unitCosts.knight.wood && 
              resources.stone >= unitCosts.knight.stone && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.knight.food;
            resources.wood -= unitCosts.knight.wood;
            resources.stone -= unitCosts.knight.stone;
            resources.population++;
            updateResourceDisplay();
            
            // Create new knight near barracks
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'knight'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
    }
    
    // Update the UI panel with building info and actions
    function updateBuildingInfo() {
      const infoDiv = document.getElementById("unitInfo");
      
      if (!selectedBuilding) {
        updateUnitInfo();
        return;
      }
      
      const healthPercent = Math.round((selectedBuilding.health / selectedBuilding.maxHealth) * 100);
      const colorClass = healthPercent > 60
        ? 'bg-emerald-500'
        : healthPercent > 30
          ? 'bg-amber-500'
          : 'bg-red-500';
          
      let productionText = 'None';
      if (selectedBuilding.type === 'farm') {
        productionText = 'Food (+10 every 5s)';
      } else if (selectedBuilding.type === 'quarry') {
        productionText = 'Stone (+8 every 6.7s)';
      } else if (selectedBuilding.type === 'lumbermill') {
        productionText = 'Wood (+12 every 5.8s)';
      } else if (selectedBuilding.type === 'house') {
        productionText = `Population Cap (+${selectedBuilding.constructionProgress >= 100 ? '3' : '0'})`;
      } else if (selectedBuilding.type === 'tower') {
        productionText = 'Defense (Attacks enemies)';
      }
      
      let html = `
        <div class="mb-4">
          <h3 class="text-lg font-bold text-amber-200 border-b border-amber-700 pb-1 mb-2">
            ${selectedBuilding.type === 'townhall' ? '🏰 Town Hall' : 
              selectedBuilding.type === 'house' ? '🏠 House' : 
              selectedBuilding.type === 'farm' ? '🌾 Farm' : 
              selectedBuilding.type === 'quarry' ? '⛏️ Quarry' : 
              selectedBuilding.type === 'lumbermill' ? '🪓 Lumber Mill' : 
              selectedBuilding.type === 'barracks' ? '⚔️ Barracks' : 
              selectedBuilding.type === 'tower' ? '🗼 Tower' : 
              selectedBuilding.type === 'castle' ? '🏯 Castle' : 
              'Building'}
          </h3>
          <div class="grid grid-cols-2 gap-2 text-sm">
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded">
              <div class="text-amber-300">Health</div>
              <div class="flex items-center">
                <div class="w-full bg-stone-700 rounded h-2 mr-2">
                  <div class="${colorClass} h-2 rounded" style="width:${healthPercent}%"></div>
                </div>
                <span>${selectedBuilding.health}/${selectedBuilding.maxHealth}</span>
              </div>
            </div>
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded">
              <div class="text-amber-300">Position</div>
              <div>${Math.round(selectedBuilding.x)}, ${Math.round(selectedBuilding.y)}</div>
            </div>
            <div class="bg-stone-800 bg-opacity-50 p-1 rounded col-span-2">
              <div class="text-amber-300">Production</div>
              <div>${productionText}</div>
            </div>
          </div>
        </div>
      `;
      
      // For townhall, add unit production buttons
      if (selectedBuilding.type === 'townhall' && selectedBuilding.constructionProgress >= 100) {
        html += `
          <div class="mt-3">
            <h4 class="text-amber-300 text-sm mb-2">Train Units</h4>
            <div class="grid grid-cols-2 gap-2">
        `;
        
        // Only show settler button if no Town Hall exists yet
        if (!townHallBuilt) {
          html += `
            <button id="trainSettler" class="px-2 py-1 bg-green-800 hover:bg-green-700 text-white rounded text-xs flex flex-col items-center">
              <span>Settler</span>
              <span class="text-amber-300">${unitCosts.settler.food} 🍖</span>
            </button>
          `;
        }
        
        html += `
          <button id="trainBuilder" class="px-2 py-1 bg-amber-800 hover:bg-amber-700 text-white rounded text-xs flex flex-col items-center">
            <span>Builder</span>
            <span class="text-amber-300">${unitCosts.builder.food} 🍖 ${unitCosts.builder.wood} 🪵</span>
          </button>
          <button id="trainWorker" class="px-2 py-1 bg-blue-800 hover:bg-blue-700 text-white rounded text-xs flex flex-col items-center">
            <span>Worker</span>
            <span class="text-amber-300">${unitCosts.worker.food} 🍖</span>
          </button>
          <button id="trainWarrior" class="px-2 py-1 bg-red-800 hover:bg-red-700 text-white rounded text-xs flex flex-col items-center">
            <span>Warrior</span>
            <span class="text-amber-300">${unitCosts.warrior.food} 🍖 ${unitCosts.warrior.wood} 🪵</span>
          </button>
            </div>
          </div>
        `;
      }
      
      // For barracks, add military unit production buttons
      if (selectedBuilding.type === 'barracks' && selectedBuilding.constructionProgress >= 100) {
        html += `
          <div class="mt-3">
            <h4 class="text-amber-300 text-sm mb-2">Train Units</h4>
            <div class="grid grid-cols-2 gap-2">
              <button id="trainArcher" class="px-2 py-1 bg-green-800 hover:bg-green-700 text-white rounded text-xs flex flex-col items-center">
                <span>Archer</span>
                <span class="text-amber-300">${unitCosts.archer.food} 🍖 ${unitCosts.archer.wood} 🪵</span>
              </button>
              <button id="trainKnight" class="px-2 py-1 bg-blue-800 hover:bg-blue-700 text-white rounded text-xs flex flex-col items-center">
                <span>Knight</span>
                <span class="text-amber-300">${unitCosts.knight.food} 🍖 ${unitCosts.knight.wood} 🪵 ${unitCosts.knight.stone} 🪨</span>
              </button>
            </div>
          </div>
        `;
      }
      
      infoDiv.innerHTML = html;
      
      // Add event listeners for buttons
      // Unit training buttons
      const trainSettler = document.getElementById("trainSettler");
      if (trainSettler) {
        trainSettler.addEventListener("click", function() {
          if (resources.food >= unitCosts.settler.food && resources.population < resources.populationCap) {
            resources.food -= unitCosts.settler.food;
            resources.population++;
            updateResourceDisplay();
            
            // Create new settler near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'settler'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough food!");
            playSound('damage');
          }
        });
      }
      
      const trainBuilder = document.getElementById("trainBuilder");
      if (trainBuilder) {
        trainBuilder.addEventListener("click", function() {
          if (resources.food >= unitCosts.builder.food && 
              resources.wood >= unitCosts.builder.wood && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.builder.food;
            resources.wood -= unitCosts.builder.wood;
            resources.population++;
            updateResourceDisplay();
            
            // Create new builder near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'builder'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
      
      const trainWorker = document.getElementById("trainWorker");
      if (trainWorker) {
        trainWorker.addEventListener("click", function() {
          if (resources.food >= unitCosts.worker.food && resources.population < resources.populationCap) {
            resources.food -= unitCosts.worker.food;
            resources.population++;
            updateResourceDisplay();
            
            // Create new worker near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'worker'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough food!");
            playSound('damage');
          }
        });
      }
      
      const trainWarrior = document.getElementById("trainWarrior");
      if (trainWarrior) {
        trainWarrior.addEventListener("click", function() {
          if (resources.food >= unitCosts.warrior.food && 
              resources.wood >= unitCosts.warrior.wood && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.warrior.food;
            resources.wood -= unitCosts.warrior.wood;
            resources.population++;
            updateResourceDisplay();
            
            // Create new warrior near townhall
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'warrior'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
      
      const trainArcher = document.getElementById("trainArcher");
      if (trainArcher) {
        trainArcher.addEventListener("click", function() {
          if (resources.food >= unitCosts.archer.food && 
              resources.wood >= unitCosts.archer.wood && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.archer.food;
            resources.wood -= unitCosts.archer.wood;
            resources.population++;
            updateResourceDisplay();
            
            // Create new archer near barracks
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'archer'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
      
      const trainKnight = document.getElementById("trainKnight");
      if (trainKnight) {
        trainKnight.addEventListener("click", function() {
          if (resources.food >= unitCosts.knight.food && 
              resources.wood >= unitCosts.knight.wood && 
              resources.stone >= unitCosts.knight.stone && 
              resources.population < resources.populationCap) {
            resources.food -= unitCosts.knight.food;
            resources.wood -= unitCosts.knight.wood;
            resources.stone -= unitCosts.knight.stone;
            resources.population++;
            updateResourceDisplay();
            
            // Create new knight near barracks
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            units.push(new Unit(
              selectedBuilding.x + Math.cos(angle) * dist,
              selectedBuilding.y + Math.sin(angle) * dist,
              'knight'
            ));
            
            // Creation particles
            particleSystem.createBurst(selectedBuilding.x, selectedBuilding.y, 'sparkle', 10);
            playSound('build');
          } else if (resources.population >= resources.populationCap) {
            showQuestNotification("Population limit reached! Build more houses.");
            playSound('damage');
          } else {
            showQuestNotification("Not enough resources!");
            playSound('damage');
          }
        });
      }
    }
    
    // Add this at the top of your script to track overlay state
    let overlayDarkness = 0;
    let overlayTint = '';
    let lastOverlayUpdate = 0;
    let currentPhase = 'day'; // 'day', 'dusk', 'night', 'dawn'
    
    // Replace the updateDayNightCycle function with this optimized version
    const overlayStyle = document.createElement('style');
    overlayStyle.textContent = `
      #dayNightOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        transition: background-color 2s ease, background 2s ease;
        will-change: background-color, background;
      }
    `;
    document.head.appendChild(overlayStyle);
    
    function updateDayNightCycle() {
      // Slower cycle - 3600 frames = 60 seconds at 60fps
      const cycleLength = 3600;
      dayNightCycle = (dayNightCycle + 1) % cycleLength;
      
      // Calculate new darkness and tint values
      let newDarkness = 0;
      let newTint = '';
      let newPhase = currentPhase;
      
      // Determine phase and calculate values
      if (dayNightCycle < cycleLength * 0.4) {
        // Day (40% of cycle)
        newPhase = 'day';
        newDarkness = 0;
        newTint = 'transparent';
      } else if (dayNightCycle < cycleLength * 0.5) {
        // Dusk (10% of cycle)
        newPhase = 'dusk';
        const duskProgress = (dayNightCycle - cycleLength * 0.4) / (cycleLength * 0.1);
        newDarkness = duskProgress * 0.7;
        
        // Smooth color transition from day to dusk
        const r = 255;
        const g = Math.floor(243 - (243 - 140) * duskProgress);
        const b = Math.floor(224 - (224 - 90) * duskProgress);
        newTint = `rgba(${r}, ${g}, ${b}, ${newDarkness * 0.3})`;
      } else if (dayNightCycle < cycleLength * 0.9) {
        // Night (40% of cycle)
        newPhase = 'night';
        newDarkness = 0.7;
        newTint = `rgba(25, 25, 112, ${newDarkness * 0.3})`;
      } else {
        // Dawn (10% of cycle)
        newPhase = 'dawn';
        const dawnProgress = (dayNightCycle - cycleLength * 0.9) / (cycleLength * 0.1);
        newDarkness = 0.7 - dawnProgress * 0.7;
        
        // Smooth color transition from night to day
        const r = Math.floor(25 + (255 - 25) * dawnProgress);
        const g = Math.floor(25 + (243 - 25) * dawnProgress);
        const b = Math.floor(112 + (224 - 112) * dawnProgress);
        newTint = `rgba(${r}, ${g}, ${b}, ${newDarkness * 0.3})`;
      }
      
      // Only update overlay when phase changes or values change significantly
      const currentTime = Date.now();
      const shouldUpdate = newPhase !== currentPhase || 
                           Math.abs(newDarkness - overlayDarkness) > 0.05 ||
                           currentTime - lastOverlayUpdate > 200;
      
      if (shouldUpdate) {
        const overlay = document.getElementById('dayNightOverlay');
        
        if (newDarkness === 0) {
          // During day, use transparent overlay
          overlay.style.background = 'transparent';
        } else {
          // During transitions and night, use gradient
          overlay.style.background = `linear-gradient(to bottom, ${newTint}, rgba(0, 0, 20, ${newDarkness}))`;
        }
        
        overlayDarkness = newDarkness;
        overlayTint = newTint;
        currentPhase = newPhase;
        lastOverlayUpdate = currentTime;
      }
      
      // New day begins
      if (dayNightCycle === 0) {
        currentDay++;
        showQuestNotification(`Day ${currentDay} begins. Your people are grateful for your leadership.`);
        resources.food += 20;
        updateResourceDisplay();
        playSound('quest');
      }
      
      // Spawn enemies at night
      if (dayNightCycle === Math.floor(cycleLength * 0.5) && questState.mainQuestComplete) {
        if (currentDay % 3 === 0 && enemyWaveNumber < 10) {
          enemyWaveNumber++;
          spawnEnemyWave();
        }
      }
    }
    
    function gameLoop() {
      globalTime++;
      
      // Update day/night cycle
      updateDayNightCycle();
      
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    function update() {
      // Update units
      units.forEach(unit => unit.update());
      
      // Update buildings
      buildings.forEach(building => building.update());
      
      // ADD THIS DAMAGE CHECK AFTER BUILDING UPDATES
      // Check if selected building was damaged and update UI
      if (selectedBuilding && selectedBuilding.wasDamaged) {
        updateBuildingInfo();
        selectedBuilding.wasDamaged = false; // Reset flag
      }
      
      // Update enemies
      enemies.forEach(enemy => enemy.update());
      
      // Update resource nodes
      resourceNodes.forEach(node => node.update());
      
      // Update movement markers
      for (let i = movementMarkers.length - 1; i >= 0; i--) {
        if (!movementMarkers[i].update()) {
          movementMarkers.splice(i, 1);
        }
      }
      
      // Update projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        if (!projectiles[i].update()) {
          projectiles.splice(i, 1);
        }
      }
      
      // Update particle system
      particleSystem.update();
      
      // Update enemy wave timer
      if (isWaveActive) {
        enemyWaveTimer++;
        
        // Check if wave is defeated
        if (enemies.length === 0 && enemyWaveTimer > 100) {
          isWaveActive = false;
          enemyWaveTimer = 0; // Reset timer for next wave
          
          // Reward for defeating wave
          resources.wood += 20 + enemyWaveNumber * 5;
          resources.stone += 15 + enemyWaveNumber * 3;
          resources.food += 10 + enemyWaveNumber * 2;
          updateResourceDisplay();
          
          showQuestNotification(`Wave ${enemyWaveNumber} defeated! Your people celebrate your victory.`);
          playSound('victory');
          
          // Check for victory
          if (enemyWaveNumber >= 10) {
            showQuestNotification("Victory! You have successfully defended your kingdom!");
            playSound('victory');
            // Could add victory screen here
          }
          
          // Add side quests after certain waves
          if (enemyWaveNumber === 3 && !questState.sideQuests.includes("Build a Quarry to produce stone")) {
            questState.sideQuests.push("Build a Quarry to produce stone");
            showQuestNotification("New Quest: Build a Quarry to produce stone");
            playSound('quest');
          }
          
          if (enemyWaveNumber === 5 && !questState.sideQuests.includes("Build a Lumber Mill to produce wood")) {
            questState.sideQuests.push("Build a Lumber Mill to produce wood");
            showQuestNotification("New Quest: Build a Lumber Mill to produce wood");
            playSound('quest');
          }
          
          if (enemyWaveNumber === 7 && !questState.sideQuests.includes("Build a Castle to win the game")) {
            questState.sideQuests.push("Build a Castle to win the game");
            showQuestNotification("New Quest: Build a Castle to win the game");
            playSound('quest');
          }
        }
      }
      
      // Update camera
      if (selectedUnit) {
        // Smooth camera follow
        const targetX = selectedUnit.x - canvas.width / 2;
        const targetY = selectedUnit.y - canvas.height / 2;
        camera.x += (targetX - camera.x) * 0.1;
        camera.y += (targetY - camera.y) * 0.1;
      } else if (selectedBuilding) {
        // Smooth camera follow
        const targetX = selectedBuilding.x - canvas.width / 2;
        const targetY = selectedBuilding.y - canvas.height / 2;
        camera.x += (targetX - camera.x) * 0.1;
        camera.y += (targetY - camera.y) * 0.1;
      } else {
        if (keysPressed["ArrowLeft"]) camera.x -= scrollSpeed;
        if (keysPressed["ArrowRight"]) camera.x += scrollSpeed;
        if (keysPressed["ArrowUp"]) camera.y -= scrollSpeed;
        if (keysPressed["ArrowDown"]) camera.y += scrollSpeed;
      }
      
      applyScreenShake(1); // simple per-frame shake
      clampCamera();
      
      // Check quest progress
      checkQuestProgress();
    }
    
    function checkQuestProgress() {
      // Check main quest
      if (!questState.mainQuestComplete) {
        for (const building of buildings) {
          if (building.type === 'townhall' && building.constructionProgress >= 100) {
            questState.mainQuestComplete = true;
            showQuestNotification("Town Hall built! Now build up your settlement and defend against enemies.");
            playSound('quest');
            
            // Add new side quests
            questState.sideQuests.push("Build 3 Houses to increase population capacity");
            questState.sideQuests.push("Build a Farm to produce food");
            questState.sideQuests.push("Train 3 Warriors to defend your settlement");
            break;
          }
        }
      }
      
      // Check side quests
      for (let i = 0; i < questState.sideQuests.length; i++) {
        const quest = questState.sideQuests[i];
        let completed = false;
        
        if (quest === "Build 3 Houses to increase population capacity") {
          let houseCount = 0;
          for (const building of buildings) {
            if (building.type === 'house' && building.constructionProgress >= 100) {
              houseCount++;
            }
          }
          if (houseCount >= 3) {
            completed = true;
          }
        } else if (quest === "Build a Farm to produce food") {
          for (const building of buildings) {
            if (building.type === 'farm' && building.constructionProgress >= 100) {
              completed = true;
              break;
            }
          }
        } else if (quest === "Train 3 Warriors to defend your settlement") {
          let warriorCount = 0;
          for (const unit of units) {
            if (unit.type === 'warrior') {
              warriorCount++;
            }
          }
          if (warriorCount >= 3) {
            completed = true;
          }
        } else if (quest === "Build a Quarry to produce stone") {
          for (const building of buildings) {
            if (building.type === 'quarry' && building.constructionProgress >= 100) {
              completed = true;
              break;
            }
          }
        } else if (quest === "Build a Lumber Mill to produce wood") {
          for (const building of buildings) {
            if (building.type === 'lumbermill' && building.constructionProgress >= 100) {
              completed = true;
              break;
            }
          }
        } else if (quest === "Build a Castle to win the game") {
          for (const building of buildings) {
            if (building.type === 'castle' && building.constructionProgress >= 100) {
              completed = true;
              break;
            }
          }
        }
        
        if (completed) {
          questState.sideQuests.splice(i, 1);
          questState.completedQuests.push(quest);
          showQuestNotification(`Quest Complete: ${quest}`);
          playSound('quest');
          
          // Reward for completing quest
          resources.wood += 30;
          resources.stone += 20;
          resources.food += 15;
          updateResourceDisplay();
          
          i--; // Adjust index after removing element
        }
      }
    }
    
    // Mouse position tracking for building placement
    let mouseX = 0;
    let mouseY = 0;
    
    canvas.addEventListener('mousemove', function(e) {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    
    canvas.addEventListener("mouseleave", () => {
      mousePos = null;
    });
    
    function draw() {
      // Clear the entire canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw the world (apply camera transformation)
      ctx.save();
      ctx.translate(-camera.x, -camera.y);
      
      // Draw textured grass background FIRST
      ctx.fillStyle = grassPattern;
      ctx.fillRect(0, 0, worldWidth, worldHeight);
      
      // Only show territories while in build mode with a builder
      if (
        buildingPlacementMode &&
        selectedUnit &&
        selectedUnit.type === 'builder'
      ) {
        drawTerritories();
      }
      
      // Draw resource nodes
      resourceNodes.forEach(node => node.draw(ctx));
      
      // Draw buildings and units
      buildings.forEach(building => building.draw(ctx));
      movementMarkers.forEach(marker => marker.draw(ctx));
      units.forEach(unit => unit.draw(ctx));
      enemies.forEach(enemy => enemy.draw(ctx));
      projectiles.forEach(projectile => projectile.draw(ctx));
      
      // Draw particle system
      particleSystem.draw(ctx);
      
      // Draw building placement preview
      if (buildingPlacementMode && selectedBuildingType) {
        const cost = buildingCosts[selectedBuildingType];
        const canAfford = resources.wood >= cost.wood && resources.stone >= cost.stone;
        
        // Get building dimensions
        let width, height;
        switch(selectedBuildingType) {
          case 'townhall':
            width = 90; height = 90;
            break;
          case 'house':
            width = 70; height = 70;
            break;
          case 'farm':
            width = 80; height = 80;
            break;
          case 'quarry':
            width = 85; height = 85;
            break;
          case 'lumbermill':
            width = 90; height = 70;
            break;
          case 'barracks':
            width = 100; height = 80;
            break;
          case 'tower':
            width = 60; height = 100;
            break;
          case 'castle':
            width = 150; height = 150;
            break;
          default:
            width = 70; height = 70;
        }
        
        // Get mouse position in world coordinates
        const worldMouseX = mouseX + camera.x;
        const worldMouseY = mouseY + camera.y;
        
        // Check if location is valid
        const inTerritory = isInTerritory(worldMouseX, worldMouseY);
        let canBuild = inTerritory;
        
        if (canBuild) {
          for (const building of buildings) {
            const dist = Math.hypot(building.x - worldMouseX, building.y - worldMouseY);
            if (dist < 100) {
              canBuild = false;
              break;
            }
          }
        }
        
        // Draw preview
        ctx.fillStyle = canAfford && canBuild ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)';
        ctx.fillRect(worldMouseX - width/2, worldMouseY - height/2, width, height);
        ctx.strokeStyle = canAfford && canBuild ? '#10b981' : '#ef4444';
        ctx.lineWidth = 2;
        ctx.strokeRect(worldMouseX - width/2, worldMouseY - height/2, width, height);
        
        // Show territory requirement if not in territory
        if (!inTerritory) {
          ctx.fillStyle = '#ef4444';
          ctx.font = 'bold 16px MedievalSharp, cursive';
          ctx.textAlign = 'center';
          ctx.fillText("Must build within territory", worldMouseX, worldMouseY - height/2 - 15);
        }
      }
      
      ctx.restore();
      
      // Draw minimap
      drawMinimap();
      
      // Draw day/night indicator
      drawDayNightIndicator();
      drawCustomCursor();
    }
    
    function drawTerritories() {
      ctx.save();
      
      // Create a clipping path for the entire world
      ctx.beginPath();
      ctx.rect(0, 0, worldWidth, worldHeight);
      ctx.clip();
      
      // Draw each territory as a semi-transparent circle
      territories.forEach(territory => {
        // Create gradient for territory
        const gradient = ctx.createRadialGradient(
          territory.x, territory.y, 0,
          territory.x, territory.y, territory.radius
        );
        gradient.addColorStop(0, 'rgba(245, 158, 11, 0.2)');
        gradient.addColorStop(1, 'rgba(245, 158, 11, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw territory border
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw territory center marker
        ctx.fillStyle = 'rgba(245, 158, 11, 0.8)';
        ctx.beginPath();
        ctx.arc(territory.x, territory.y, 5, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.restore();
    }
    
    function drawDayNightIndicator() {
      const indicatorSize = 30;
      const x = canvas.width / 2;
      const y = 30;
      const cycleLength = 3600; // 60 seconds at 60fps
      
      ctx.save();
      
      // Background circle
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.beginPath();
      ctx.arc(x, y, indicatorSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Outer ring
      ctx.beginPath();
      ctx.arc(x, y, indicatorSize - 5, 0, Math.PI * 2);
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Compute sun/moon angle
      const angle = (dayNightCycle / cycleLength) * Math.PI * 2 - Math.PI / 2;
      const sunMoonX = x + Math.cos(angle) * (indicatorSize - 10);
      const sunMoonY = y + Math.sin(angle) * (indicatorSize - 10);
      
      // Determine time phase and interpolate colors smoothly
      let sunMoonColor;
      
      if (dayNightCycle < cycleLength * 0.4) {
        // Day - bright yellow sun
        sunMoonColor = '#f59e0b';
      } else if (dayNightCycle < cycleLength * 0.5) {
        // Dusk - transition from yellow to orange to dark orange
        const duskProgress = (dayNightCycle - cycleLength * 0.4) / (cycleLength * 0.1);
        const r = Math.floor(245 - (245 - 180) * duskProgress); // 245 → 180
        const g = Math.floor(158 - (158 - 80) * duskProgress);   // 158 → 80
        const b = Math.floor(11 - (11 - 20) * duskProgress);     // 11 → 20
        sunMoonColor = `rgb(${r}, ${g}, ${b})`;
      } else if (dayNightCycle < cycleLength * 0.9) {
        // Night - gray moon
        sunMoonColor = '#e5e7eb';
      } else {
        // Dawn - transition from gray to yellow
        const dawnProgress = (dayNightCycle - cycleLength * 0.9) / (cycleLength * 0.1);
        const r = Math.floor(229 + (245 - 229) * dawnProgress); // 229 → 245
        const g = Math.floor(231 + (158 - 231) * dawnProgress); // 231 → 158
        const b = Math.floor(235 + (11 - 235) * dawnProgress);  // 235 → 11
        sunMoonColor = `rgb(${r}, ${g}, ${b})`;
      }
      
      // Draw sun/moon with smooth color transition
      ctx.fillStyle = sunMoonColor;
      ctx.beginPath();
      ctx.arc(sunMoonX, sunMoonY, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Add a subtle glow effect during transitions
      if (dayNightCycle >= cycleLength * 0.4 && dayNightCycle < cycleLength * 0.5) {
        // Dusk glow
        const duskProgress = (dayNightCycle - cycleLength * 0.4) / (cycleLength * 0.1);
        ctx.shadowBlur = 15 * (1 - duskProgress);
        ctx.shadowColor = 'rgba(245, 158, 11, 0.5)';
        ctx.beginPath();
        ctx.arc(sunMoonX, sunMoonY, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (dayNightCycle >= cycleLength * 0.9) {
        // Dawn glow
        const dawnProgress = (dayNightCycle - cycleLength * 0.9) / (cycleLength * 0.1);
        ctx.shadowBlur = 15 * dawnProgress;
        ctx.shadowColor = 'rgba(245, 158, 11, 0.5)';
        ctx.beginPath();
        ctx.arc(sunMoonX, sunMoonY, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
      
      // Day counter
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 16px Cinzel, serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Day ${currentDay}`, x, y + indicatorSize + 20);
      
      ctx.restore();
    }
    
    function drawMinimap() {
      const minimapWidth = 200;
      const minimapHeight = 200;
      const minimapX = canvas.width - minimapWidth - 10;
      const minimapY = canvas.height - minimapHeight - 10;
      const scaleX = minimapWidth / worldWidth;
      const scaleY = minimapHeight / worldHeight;
      
      ctx.save();
      
      // Draw medieval-style background with parchment texture
      ctx.fillStyle = "#d4a76a";
      ctx.fillRect(minimapX, minimapY, minimapWidth, minimapHeight);
      
      // Add parchment texture with subtle noise
      ctx.fillStyle = "rgba(139, 90, 43, 0.1)";
      for (let i = 0; i < 200; i++) {
        const x = minimapX + Math.random() * minimapWidth;
        const y = minimapY + Math.random() * minimapHeight;
        const size = Math.random() * 2;
        ctx.fillRect(x, y, size, size);
      }
      
      // Draw ornate border with medieval styling
      ctx.strokeStyle = "#8b6914";
      ctx.lineWidth = 3;
      ctx.strokeRect(minimapX, minimapY, minimapWidth, minimapHeight);
      
      // Draw inner border
      ctx.strokeStyle = "#5a4310";
      ctx.lineWidth = 1;
      ctx.strokeRect(minimapX + 5, minimapY + 5, minimapWidth - 10, minimapHeight - 10);
      
      // Draw corner decorations
      const cornerSize = 15;
      ctx.fillStyle = "#8b6914";
      
      // Top-left corner
      ctx.beginPath();
      ctx.moveTo(minimapX, minimapY + cornerSize);
      ctx.lineTo(minimapX, minimapY);
      ctx.lineTo(minimapX + cornerSize, minimapY);
      ctx.stroke();
      
      // Top-right corner
      ctx.beginPath();
      ctx.moveTo(minimapX + minimapWidth - cornerSize, minimapY);
      ctx.lineTo(minimapX + minimapWidth, minimapY);
      ctx.lineTo(minimapX + minimapWidth, minimapY + cornerSize);
      ctx.stroke();
      
      // Bottom-left corner
      ctx.beginPath();
      ctx.moveTo(minimapX, minimapY + minimapHeight - cornerSize);
      ctx.lineTo(minimapX, minimapY + minimapHeight);
      ctx.lineTo(minimapX + cornerSize, minimapY + minimapHeight);
      ctx.stroke();
      
      // Bottom-right corner
      ctx.beginPath();
      ctx.moveTo(minimapX + minimapWidth - cornerSize, minimapY + minimapHeight);
      ctx.lineTo(minimapX + minimapWidth, minimapY + minimapHeight);
      ctx.lineTo(minimapX + minimapWidth, minimapY + minimapHeight - cornerSize);
      ctx.stroke();
      
      // Draw compass rose with medieval styling
      const compassX = minimapX + minimapWidth - 25;
      const compassY = minimapY + 25;
      const compassRadius = 15;
      
      // Compass background
      ctx.fillStyle = "rgba(40, 30, 20, 0.7)";
      ctx.beginPath();
      ctx.arc(compassX, compassY, compassRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Compass border
      ctx.strokeStyle = "#8b6914";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(compassX, compassY, compassRadius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Compass directions
      ctx.fillStyle = "#fcd34d";
      ctx.font = "bold 12px 'MedievalSharp', cursive";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("N", compassX, compassY - compassRadius + 5);
      
      // Draw compass needle
      ctx.strokeStyle = "#ef4444";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(compassX, compassY);
      ctx.lineTo(compassX, compassY - compassRadius + 7);
      ctx.stroke();
      
      // Draw map title
      ctx.fillStyle = "#5a4310";
      ctx.font = "bold 14px 'Cinzel', serif";
      ctx.textAlign = "center";
      ctx.fillText("REALM MAP", minimapX + minimapWidth / 2, minimapY + 185);
      
      // Draw world representation with medieval colors
      ctx.fillStyle = "rgba(46, 125, 87, 0.3)";
      ctx.fillRect(minimapX, minimapY, minimapWidth, minimapHeight);
      
      // Set clipping region for territories to prevent overflow
      ctx.save();
      ctx.beginPath();
      ctx.rect(minimapX, minimapY, minimapWidth, minimapHeight);
      ctx.clip();
      
      // Draw territories on minimap with medieval styling
      territories.forEach(territory => {
        const tx = minimapX + territory.x * scaleX;
        const ty = minimapY + territory.y * scaleY;
        const tr = territory.radius * scaleX;
        
        // Skip if entirely outside minimap
        if (tx + tr < minimapX || tx - tr > minimapX + minimapWidth ||
            ty + tr < minimapY || ty - tr > minimapY + minimapHeight) {
          return;
        }
        
        // Territory gradient
        const gradient = ctx.createRadialGradient(tx, ty, 0, tx, ty, tr);
        gradient.addColorStop(0, 'rgba(245, 158, 11, 0.3)');
        gradient.addColorStop(1, 'rgba(245, 158, 11, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(tx, ty, tr, 0, Math.PI * 2);
        ctx.fill();
        
        // Territory border
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.7)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.arc(tx, ty, tr, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw territory center
        ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';
        ctx.beginPath();
        ctx.arc(tx, ty, 2, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Restore clipping region
      ctx.restore();
      
      // Draw resource nodes with medieval icons
      resourceNodes.forEach(node => {
        if (node.amount > 0) {
          const nx = minimapX + node.x * scaleX;
          const ny = minimapY + node.y * scaleY;
          
          // Skip if outside minimap bounds
          if (nx < minimapX || nx > minimapX + minimapWidth || 
              ny < minimapY || ny > minimapY + minimapHeight) {
            return;
          }
          
          if (node.type === 'tree') {
            // Draw tree icon
            ctx.fillStyle = "#2E8B57";
            ctx.fillRect(nx - 2, ny - 1, 4, 4);
            ctx.beginPath();
            ctx.moveTo(nx, ny - 3);
            ctx.lineTo(nx - 3, ny + 1);
            ctx.lineTo(nx + 3, ny + 1);
            ctx.closePath();
            ctx.fill();
          } else if (node.type === 'rock') {
            // Draw rock icon
            ctx.fillStyle = "#808080";
            ctx.beginPath();
            ctx.arc(nx, ny, 2, 0, Math.PI * 2);
            ctx.fill();
          } else if (node.type === 'bush') {
            // Draw bush icon
            ctx.fillStyle = "#228B22";
            ctx.beginPath();
            ctx.arc(nx - 1, ny, 1.5, 0, Math.PI * 2);
            ctx.arc(nx + 1, ny, 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      // Draw buildings with medieval icons
      buildings.forEach(building => {
        const bx = minimapX + building.x * scaleX;
        const by = minimapY + building.y * scaleY;
        
        // Skip if outside minimap bounds
        if (bx < minimapX || bx > minimapX + minimapWidth || 
            by < minimapY || by > minimapY + minimapHeight) {
          return;
        }
        
        // Building colors
        let color;
        if (building.type === 'townhall') color = "#8B4513";
        else if (building.type === 'house') color = "#A0522D";
        else if (building.type === 'farm') color = "#2E8B57";
        else if (building.type === 'quarry') color = "#808080";
        else if (building.type === 'lumbermill') color = "#8B4513";
        else if (building.type === 'barracks') color = "#4B0082";
        else if (building.type === 'tower') color = "#696969";
        else if (building.type === 'castle') color = "#8B0000";
        else color = "#5a3921";
        
        // For planned buildings, use a different color
        if (building.constructionProgress === -1) {
          color = "#888888";
        }
        
        // Draw building shape based on type
        ctx.fillStyle = color;
        
        if (building.type === 'townhall' || building.type === 'castle') {
          // Draw larger building for important structures
          ctx.fillRect(bx - 4, by - 4, 8, 8);
          // Add tower tops
          ctx.fillRect(bx - 5, by - 6, 3, 3);
          ctx.fillRect(bx + 2, by - 6, 3, 3);
        } else if (building.type === 'tower') {
          // Draw tall tower
          ctx.fillRect(bx - 2, by - 5, 4, 8);
        } else {
          // Draw standard building
          ctx.fillRect(bx - 3, by - 3, 6, 6);
        }
        
        // Show planned indicator on minimap
        if (building.constructionProgress === -1) {
          ctx.strokeStyle = "#facc15";
          ctx.lineWidth = 1;
          ctx.strokeRect(bx - 4, by - 4, 8, 8);
        }
        
        // Show construction progress
        if (building.constructionProgress > 0 && building.constructionProgress < 100) {
          ctx.fillStyle = "rgba(245, 158, 11, 0.7)";
          ctx.fillRect(bx - 4, by - 6, 8 * (building.constructionProgress/100), 1);
        }
      });
      
      // Draw units with medieval icons
      units.forEach(unit => {
        const ux = minimapX + unit.x * scaleX;
        const uy = minimapY + unit.y * scaleY;
        
        // Skip if outside minimap bounds
        if (ux < minimapX || ux > minimapX + minimapWidth || 
            uy < minimapY || uy > minimapY + minimapHeight) {
          return;
        }
        
        // Unit colors
        let color;
        if (unit.type === 'warrior' || unit.type === 'archer' || unit.type === 'knight') color = "#3b82f6";
        else if (unit.type === 'settler') color = "#10b981";
        else if (unit.type === 'builder') color = "#f59e0b";
        else color = "#8b5cf6"; // Worker
        
        // Draw unit shape based on type
        ctx.fillStyle = color;
        
        if (unit.type === 'knight') {
          // Draw knight with helmet
          ctx.beginPath();
          ctx.arc(ux, uy, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(ux - 1, uy - 4, 2, 2);
        } else if (unit.type === 'warrior') {
          // Draw warrior with sword
          ctx.beginPath();
          ctx.arc(ux, uy, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(ux + 2, uy - 1, 2, 1);
        } else if (unit.type === 'archer') {
          // Draw archer with bow
          ctx.beginPath();
          ctx.arc(ux, uy, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(ux - 2, uy - 2);
          ctx.lineTo(ux + 2, uy + 2);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (unit.type === 'builder') {
          // Draw builder with hammer
          ctx.beginPath();
          ctx.arc(ux, uy, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(ux + 1, uy - 2, 2, 1);
        } else if (unit.type === 'worker') {
          // Draw worker with pickaxe
          ctx.beginPath();
          ctx.arc(ux, uy, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(ux - 1, uy - 2);
          ctx.lineTo(ux + 1, uy + 1);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke();
        } else {
          // Draw settler
          ctx.beginPath();
          ctx.arc(ux, uy, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Highlight selected unit
        if (unit.selected) {
          ctx.strokeStyle = "#facc15";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(ux, uy, 4, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
      
      // Draw enemies with medieval icons
      enemies.forEach(enemy => {
        const ex = minimapX + enemy.x * scaleX;
        const ey = minimapY + enemy.y * scaleY;
        
        // Skip if outside minimap bounds
        if (ex < minimapX || ex > minimapX + minimapWidth || 
            ey < minimapY || ey > minimapY + minimapHeight) {
          return;
        }
        
        // Enemy colors
        const color = enemy.type === 'raider' ? "#8B0000" : "#696969";
        
        // Draw enemy shape based on type
        ctx.fillStyle = color;
        
        if (enemy.type === 'raider') {
          // Draw raider with sword
          ctx.beginPath();
          ctx.arc(ex, ey, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(ex + 2, ey - 1, 2, 1);
        } else {
          // Draw wolf
          ctx.beginPath();
          ctx.arc(ex, ey, 2.5, 0, Math.PI * 2);
          ctx.fill();
          // Draw ears
          ctx.beginPath();
          ctx.moveTo(ex - 1.5, ey - 2);
          ctx.lineTo(ex - 2.5, ey - 3.5);
          ctx.lineTo(ex - 1, ey - 2.5);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(ex + 1.5, ey - 2);
          ctx.lineTo(ex + 2.5, ey - 3.5);
          ctx.lineTo(ex + 1, ey - 2.5);
          ctx.fill();
        }
      });
      
      // Draw the current viewport with medieval styling
      const viewportRectX = minimapX + camera.x * scaleX;
      const viewportRectY = minimapY + camera.y * scaleY;
      const viewportRectWidth = canvas.width * scaleX;
      const viewportRectHeight = canvas.height * scaleY;
      
      // Viewport border with medieval style
      ctx.strokeStyle = "#fcd34d";
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 2]);
      ctx.strokeRect(viewportRectX, viewportRectY, viewportRectWidth, viewportRectHeight);
      ctx.setLineDash([]);
      
      // Draw viewport corner indicators
      ctx.fillStyle = "#fcd34d";
      const cornerSize2 = 4;
      
      // Top-left
      ctx.fillRect(viewportRectX - cornerSize2, viewportRectY - cornerSize2, cornerSize2, cornerSize2);
      // Top-right
      ctx.fillRect(viewportRectX + viewportRectWidth, viewportRectY - cornerSize2, cornerSize2, cornerSize2);
      // Bottom-left
      ctx.fillRect(viewportRectX - cornerSize2, viewportRectY + viewportRectHeight, cornerSize2, cornerSize2);
      // Bottom-right
      ctx.fillRect(viewportRectX + viewportRectWidth, viewportRectY + viewportRectHeight, cornerSize2, cornerSize2);
      
      ctx.restore();
    }
    
    const buildingDetails = {
      house: {
        name: "House",
        cost: { wood: 30, stone: 10 },
        description: "Increases population capacity by 3. Provides shelter for your settlers.",
        icon: "🏠"
      },
      farm: {
        name: "Farm",
        cost: { wood: 40, stone: 20 },
        description: "Produces food over time. Essential for sustaining your population.",
        icon: "🌾"
      },
      quarry: {
        name: "Quarry",
        cost: { wood: 30, stone: 30 },
        description: "Produces stone over time. Needed for advanced structures.",
        icon: "⛏️"
      },
      lumbermill: {
        name: "Lumber Mill",
        cost: { wood: 50, stone: 10 },
        description: "Produces wood over time. Vital for construction and unit training.",
        icon: "🪓"
      },
      barracks: {
        name: "Barracks",
        cost: { wood: 60, stone: 40 },
        description: "Trains military units. Essential for defending your settlement.",
        icon: "⚔️"
      },
      tower: {
        name: "Tower",
        cost: { wood: 40, stone: 60 },
        description: "Defensive structure that automatically attacks nearby enemies.",
        icon: "🗼"
      }
    };
    
    // Add this function to update the UI with building details
    function updateBuildingMenuInfo(buildingType) {
      const infoDiv = document.getElementById("unitInfo");
      const details = buildingDetails[buildingType];
      
      if (!details) return;
      
      // Check if player can afford the building
      const canAfford = resources.wood >= details.cost.wood && resources.stone >= details.cost.stone;
      const affordabilityClass = canAfford ? 'text-emerald-400' : 'text-red-400';
      
      const html = `
        <div class="mb-4">
          <h3 class="text-xl font-bold text-amber-200 border-b border-amber-700 pb-2 mb-3 flex items-center">
            <span class="text-2xl mr-2">${details.icon}</span>
            ${details.name}
          </h3>
          
          <div class="bg-stone-800 bg-opacity-50 p-3 rounded-lg mb-3">
            <h4 class="text-amber-300 font-semibold mb-2">Cost</h4>
            <div class="grid grid-cols-2 gap-2">
              <div class="flex items-center">
                <span class="text-lg mr-2">🪵</span>
                <span class="${resources.wood >= details.cost.wood ? 'text-emerald-400' : 'text-red-400'}">${details.cost.wood} Wood</span>
              </div>
              <div class="flex items-center">
                <span class="text-lg mr-2">🪨</span>
                <span class="${resources.stone >= details.cost.stone ? 'text-emerald-400' : 'text-red-400'}">${details.cost.stone} Stone</span>
              </div>
            </div>
          </div>
          
          <div class="bg-stone-800 bg-opacity-50 p-3 rounded-lg">
            <h4 class="text-amber-300 font-semibold mb-2">Description</h4>
            <p class="text-amber-100 text-sm">${details.description}</p>
          </div>
          
          <div class="mt-4 p-3 rounded-lg ${canAfford ? 'bg-emerald-900 bg-opacity-30' : 'bg-red-900 bg-opacity-30'}">
            <p class="${affordabilityClass} font-semibold text-center">
              ${canAfford ? '✓ Can afford this building' : '✗ Not enough resources'}
            </p>
          </div>
          
          <div class="mt-4 text-center">
            <p class="text-amber-300 text-sm">Click on the map to place this building</p>
            <p class="text-amber-500 text-xs mt-1">Must be built within your territory</p>
          </div>
        </div>
      `;
      
      infoDiv.innerHTML = html;
    }
    
    // Add this function to restore the builder's normal info display
    function restoreBuilderInfo() {
      updateUnitInfo(); // This will show the normal builder info
    }
    
    init();
    gameLoop();
    
    // Prevent zooming with mouse wheel
    document.addEventListener('wheel', function(e) {
      if (e.ctrlKey) {
        e.preventDefault();
      }
    }, { passive: false });
    
    // Prevent pinch-to-zoom on touch devices
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);
    
    // Prevent double-tap to zoom
    let lastTouchStart = 0;
    document.addEventListener('touchstart', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
      lastTouchStart = Date.now();
    }, false);
    
    document.addEventListener('touchmove', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, false);
  </script>
</body>
</html>
